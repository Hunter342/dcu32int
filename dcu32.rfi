/*            
This file describes the results of reverse engineering the DCU file format for
Delphi 2.0-8.0, 2005(.net and WIN32), 2006(.net and WIN32)/Turbo Delphi,
2009,2010,XE1-XE7/AppMethod, Kylix 1.0-3.0.
Note, that the FlexT file describes only the DCU memory layout aspects of file
format. The Pascal code for parsing DCUs (DCU32INT project) is published at
http://hmelnov.icc.ru/DCU/
*/

data
  0x0000 ulong Magic

type
  TPlatformName enum byte of (win32,win64,osx32,iosEmulator,iosDevice32,iosDevice64,Android,Linux64)

%$IF Magic=0xF21F148C;
//Kylix1.0
const
  Ver=100;
descr ('Borland Kylix 1.0 unit file.')
%$ELSIF Magic=0x0E1011DD;
//Kylix2.0
const
  Ver=101;
descr ('Borland Kylix 2.0 unit file.')
%$ELSIF Magic=0x0E0001DD;
//Kylix2.0, another magic
const
  Ver=101;
descr ('Borland Kylix 2.0 unit file (kind $00).')
%$ELSIF (Magic=0x0F1001DD)or(Magic=0x0F0001DD);
//Kylix3.0
const
  Ver=102;
descr ('Borland Kylix 3.0 unit file.')
%$ELSIF Magic=0x1600034B;
//Delphi XE
const
  Ver=14;
descr ('Borland Delphi XE unit file.')
%$ELSIF Magic=0x15000045;
//Delphi2010
const
  Ver=13;
descr ('Borland Delphi 2010 unit file.')
%$ELSIF Magic=0x14000039;
//Delphi2009
const
  Ver=12;
descr ('Borland Delphi 2009 unit file.')
%$ELSIF Magic=0x1200024D;
//Delphi 2006 .net
const
  Ver=10;
  MSIL=1;
descr ('Borland Delphi 2006 unit file.')
%$ELSIF Magic=0x12000023;
//Delphi 2006
const
  Ver=10;
descr ('Borland Delphi 2006 unit file.')
%$ELSIF Magic=0x11000239;
//Delphi 2005 .net
const
  Ver=9;
  MSIL=1;
descr ('Borland Delphi 2005 MSIL unit file.')
%$ELSIF (Magic=0x1100000D)or(Magic=0x11800009); //0x11800009 in DUnitMainForm.dcu
//Delphi 2005
const
  Ver=9;
descr ('Borland Delphi 2005 unit file.')
%$ELSIF Magic=0x10000229;
//Delphi8.0
const
  Ver=8;
  MSIL=1;
descr ('Borland Delphi 8.0 MSIL unit file.')
%$ELSIF Magic and 0xFF80FFFF=0xFF0000DF;
//Delphi7.0
const
  Ver=7;
descr ('Borland Delphi 7.0 (Free) unit file.')
%$ELSIF Magic and 0xFF00FFFF=0x0F0000DF;
//Delphi7.0
const
  Ver=7;
descr ('Borland Delphi 7.0 unit file.')
%$ELSIF Magic and 0xFF80FFFF=0x0E0000DD;
//Delphi6.0
const
  Ver=6;
descr ('Borland Delphi 6.0 unit file.')
%$ELSIF Magic and 0xFF80FFFF=0x0E8000DD;
//Delphi6.0, another magic
const
  Ver=6;
descr ('Borland Delphi 6.0 unit file (kind $80).')
%$ELSIF Magic=0xF21F148B;
//Delphi5.0
const
  Ver=5;
descr ('Borland Delphi 5.0 unit file.')
%$ELSIF Magic=0x4768A6D8;
//Delphi4.0
const
  Ver=4;
descr ('Borland Delphi 4.0 unit file.')
%$ELSIF Magic=0x44518641; //'A†QD'
//Delphi3.0
const
  Ver=3;
descr ('Borland Delphi 3.0 unit file.')
%$ELSIF Magic=0x50505348; //HSPP
//Delphi2.0
const
  Ver=2;
descr ('Borland Delphi 2.0 unit file.')
%$ELSIF Magic and 0x00FF00F9=0x00000049; 
const
  Ver=(Magic shr 24)-8;

  %$IF (Ver<=25)and(Ver>=19)and(Magic and 0xFF=0x4D)or
     (Ver<=18)and(Ver>=15)and(Magic and 0xFF=0x4B);
  //24 - 0x2000xx4D Borland Delphi 10.2 Tokyo
  //23 - 0x1F00xx4D Borland Delphi 10.1 Berlin
  //22 - 0x1E00xx4D Borland Delphi 10 Seattle
  //21 - 0x1D00xx4D Borland Delphi XE8
  //20 - 0x1C00xx4D Borland Delphi XE7
  //19 - 0x1B00xx4D Borland Delphi XE6
  //18 - 0x1A00xx4B Borland Delphi XE5
  //17 - 0x1900xx4B Borland Delphi XE4
  //16 - 0x1800xx4B Borland Delphi XE3
  //15 - 0x1700xx4B Borland Delphi XE2

  const
    PlMagic=(Magic shr 8)and 0xFF;
  %$ELSE
  assert 0; //fail
  %$END

  %$IF PlMagic=0x03;
  const
    cPlatform=TPlatformName.win32;
  %$ELSIF PlMagic=0x23;
  const
    cPlatform=TPlatformName.win64;
    mode64=1;
  %$ELSIF PlMagic=0x04;
  const
    cPlatform=TPlatformName.osx32;
  %$ELSIF (PlMagic=0x14)and(Ver>=17/*XE4*/);
  const
    cPlatform=TPlatformName.iosEmulator;
    iOs=1;
    Mobile=1;
  %$ELSIF (PlMagic=0x76)and(Ver>=17/*XE4*/);
  const
    cPlatform=TPlatformName.iosDevice32;
    iOs=2;
    Mobile=1;
  %$ELSIF (PlMagic=0x94)and(Ver>=21/*XE8*/);
  const
    cPlatform=TPlatformName.iosDevice64;
    iOs=2;
    mode64=1;
    Mobile=1;
  %$ELSIF (PlMagic=0x77)and(Ver>=18/*XE5*/);
  const
    cPlatform=TPlatformName.Android;
    iOs=3;
    Mobile=1;
  %$ELSIF (PlMagic=0x21)and(Ver>=24/*10.2 Tokyo*/);
  const
    cPlatform=TPlatformName.Linux64;
    mode64=1;
    ARC = 1; //Automatic reference count
  %$ELSE
    assert 0; //fail
  %$END

descr ('Borland Delphi ',
  case Ver of
   25: ('10.3 Rio')
   24: ('10.2 Tokyo')
   23: ('10.1 Berlin')
   22: ('10 Seattle')
   else ('XE',INT(Ver-13))
  endc, ' (',valname(cPlatform,TPlatformName),') unit file.')

%$ELSE
assert 0; //fail
%$END

%$IF not defined MSIL;
const
MSIL=0;
%$END

%$IF not defined Packaged;
const
Packaged=0;
%$END     

%$IF Packaged;
%$IF (Ver<6); 
const
  PkgNdxFlag=0x80;
%$ELSE
const
  PkgNdxFlag=0x100;
%$END
%$END
%$IF not defined mode64;
const
mode64=0;
%$END

%$IF not defined iOs;
const
iOs=0;
%$END

%$IF not defined ARC;
const
ARC=iOs>0;
%$END

%$IF not defined Mobile;
const
Mobile=0;
%$END

%$IF not defined cPlatform;
const
cPlatform=0;
%$END


descr (NL,
  'Info Src: Partially reconstructed by me (Alexei Hmelnov (mailto:alex@icc.ru)).',NL,
  'Info Src: DoDi''s DCU Documentation (mailto:VBDis@aol.com)',NL)

const
  IsKylix = Ver>=100;
  IsDelphi = Ver<100;
  gen7 = (Ver>=7) and IsDelphi or (Ver>=102);

type

TDCU30RecTag enum char of (
  drStop=0,
  drStop_a='a', //Last Tag in all files
  drStop1='c',
 %$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
  drAssemblyData='b', //Last Tag of Assembly description?
 %$END
  drUnit='d',
  drUnit1='e', //in implementation
  drImpType='f',
  drImpVal='g',
  drDLL='h',
  drExport='i',
  drEmbeddedProcStart='j',
  drEmbeddedProcEnd='k',
  drCBlock='l',
  drFixUp='m',
  drImpTypeDef='n', //import of type definition by "A = type B"
%$IF (Ver>=8)and IsDelphi;
  drORec='o', //goes before drCBlock
 %$IF (Ver>=10)and IsDelphi;
  drStrConstRec='6',
 %$ELSE
  drStrConstRec='5',
 %$END
%$END
  drSrc='p',
  drObj='q',
  drRes='r',
  drAsm='s', //Observed in D5
 %$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
  drAssemblySrc='t',
 %$END
  drStop2='Ÿ', //!!!
  drConst=0x25, //'%',

 %$IF (Ver>=10)and IsDelphi;
  drThreadVar='2',
  drResStr='3',
 %$ELSE
  drThreadVar='1',
  drResStr='2',
 %$END

  drType='*',
  drTypeP='&',
  drProc='(',
  drSysProc=')',
  drVar=0x20, //' ',
  drVarC=0x27, //''',
  drAbsVar='$',
  drVoid='@',
  drLabel='+',
  drBoolRangeDef='A',
  drChRangeDef='B',
  drEnumDef='C',
  drRangeDef='D',
  drPtrDef='E',
  drClassDef='F',
  drObjVMTDef='G',
  drProcTypeDef='H',
  drFloatDef='I',
  drSetDef='J',
  drShortStrDef='K',
  drArrayDef='L',
  drRecDef='M',
  drObjDef='N',
  drFileDef='O',
  drTextDef='P',
  drWCharRangeDef='Q', //WideChar
  drStringDef='R',
  drVariantDef='S',
  drInterfaceDef='T',
  drWideStrDef='U',
  drWideRangeDef='V',
%$IF (Ver>=8)and IsDelphi;
  drMetaClassDef='W', //?? guess name
 %$IF (Ver>=12)and IsDelphi;
  drDynArrayDef='X', //Separate from drArrayDef tag now
  drTemplateArgDef='Y',
  drTemplateCall='Z',
  drUnicodeStringDef='[',
 %$IF (Ver>=13)and IsDelphi;
  drUnitInlineSrc='v',
 %$END
 %$END
%$END
//Various tables
  drCodeLines=0x90,
  drLinNum=0x91,
  drStrucScope=0x92,
  drSymbolRef=0x93,
  drLocVarTbl=0x94,
  drUnitFlags=0x96,
%$IF IsKylix; //Kylix specific flags
 // drUnit3=0xE0, //4-bytes record, present in almost all units
 // drUnit3s=0x06, //3-bytes record, present in System and SysInit
  drUnit4=0x0F, //5-bytes record, was observed in QOpenBanner.dcu only
%$ELSIF Ver>=7;
 %$IF (Ver>=10)and IsDelphi;
  drUnitAddInfo='5',
 %$ELSE
  drUnitAddInfo='4',
 %$END
  drProcAddInfo=0x9E,
%$END
%$IF gen7;
  drConstAddInfo=0x9C, //caused by the "platform" keyword
%$END
%$IF (Ver>=9)and(Ver<=10)and MSIL;
  drAssemblyInfo=0x9D, //The unit is from package generated for assemmbly
%$END
%$IF (Ver>=3)and IsDelphi;
  drCPPFlags=0x98,
%$END
%$IF (Ver>=10)and IsDelphi;
//  drAddInfo6='6',
  drSpecVar='7',
  drCLine=0xA0,
  drA1Info=0xA1,
  drA2Info=0xA2,
 %$IF (Ver>=12)and IsDelphi;
  arCopyDecl=0xA3,
  drA5Info=0xA5,
  drA6Info=0xA6,
  drA7Info=0xA7,
  drA8Info=0xA8,
 %$IF (Ver>=17)and IsDelphi;
  drA9Info=0xA9,
 %$END
  drDelayedImpInfo=0xB0,
 %$END
 %$IF (Ver>=15)and IsDelphi /*and mode64*/;
  drSegInfo=0xB1,
  drAddrToSegInfo=0xB2,
 %$END
 %$IF (Ver>=20)and IsDelphi;
  drNextOverload=0xB6,
 %$END
 %$IF (Ver>=22)and IsDelphi;
  drDependencyInfo=0xB5,
 %$END
%$END
  drSetDeft=0x9A //Set Default parameter value
)

include Float.rfi

type bit
/*
  TBit num+(1)
  TBit2 num+(2)
  TBit3 num+(3)
  TBit4 num+(4)
  TBit8 num+(8)
 */
  TBit7 num+(7)
  TBit14 num+(14)
  TBit21 num+(21)
  TBit28 num+(28)
  TBit32 num+(32)

  TNDXB1b struc pas
    F: TBit
    V: TBit7
  ends:assert[@.F=0]: displ=(HEX(@.V))

  TNDXB2b struc pas
    F: TBit2
    V: TBit14
  ends:assert[@.F=0x1]: displ=(HEX(@.V))

  TNDXB3b struc pas
    F: TBit3
    V: TBit21
  ends:assert[@.F=0x3]: displ=(HEX(@.V))

  TNDXB4b struc pas
    F: TBit4
    V: TBit28
  ends:assert[@.F=0x7]: displ=(HEX(@.V))

  TNDXB5b struc pas
    F: TBit8
    V: TBit32
  ends:assert[@.F=0xF]: displ=(HEX(@.V))

  TNDXB9b struc pas
    F: TBit8  //F=0xFF: Delphi 4.0 - 64 bit
    Lo: TBit32
    Hi: TBit32
  ends: displ=(HEX(@.Hi),HEX(@.Lo,8))

  TNDXB1 try
   b1: TNDXB1b
   b2: TNDXB2b
   b3: TNDXB3b
   b4: TNDXB4b
   b5: TNDXB5b
   b9: TNDXB9b
  endt: displ=('#',@):let Val=@.b1.V exc @.b2.V exc @.b3.V exc
    @.b4.V exc @.b5.V exc @.b9.Lo/*8-byte values are not supported in FlexT yet*/;

  TSBit7 num-(7)
  TSBit14 num-(14)
  TSBit21 num-(21)
  TSBit28 num-(28)
  TSBit32 num-(32)

  TSNDXB1b struc pas
    F: TBit
    V: TSBit7
  ends:assert[@.F=0]: displ=(INT(@.V))

  TSNDXB2b struc pas
    F: TBit2
    V: TSBit14
  ends:assert[@.F=0x1]: displ=(INT(@.V))

  TSNDXB3b struc pas
    F: TBit3
    V: TSBit21
  ends:assert[@.F=0x3]: displ=(INT(@.V))

  TSNDXB4b struc pas
    F: TBit4
    V: TSBit28
  ends:assert[@.F=0x7]: displ=(INT(@.V))

  TSNDXB5b struc pas
    F: TBit8
    V: TSBit32
  ends:assert[@.F=0xF]: displ=(INT(@.V))

  TSNDXB9b struc pas
    F: TBit8  //F=0xFF: Delphi 4.0 - 64 bit
    Lo: TBit32
    Hi: TBit32
  ends: displ=(HEX(@.Hi),HEX(@.Lo,8))

  TSNDXB1 try
   b1: TSNDXB1b
   b2: TSNDXB2b
   b3: TSNDXB3b
   b4: TSNDXB4b
   b5: TSNDXB5b
   b9: TSNDXB9b
  endt: displ=('!',@):let Val=@.b1.V exc @.b2.V exc @.b3.V exc
    @.b4.V exc @.b5.V exc @.b9.Lo/*8-byte values are not supported in FlexT yet*/;

/*
  TNDXB1 struc pas
    IsW: TBit
    V: case @.IsW of
     0: TBit7
     else struc pas
       IsB3: TBit
       V: case @.IsB3 of
        0: TBit14
        else struc pas
          IsB4: TBit
          V: case @.IsB4 of
           0: TBit21
           else struc pas
             IsB5: TBit
             V: case @.IsB5 of
              0: TBit28
              else struc pas
                Z: TBit4
                V: case @.Z of
                  0: TBit32
                  else struc pas //0xF: Delphi 4.0 - 64 bit
                    Lo: TBit32
                    Hi: TBit32
                  ends: displ=(HEX(@.Hi),HEX(@.Lo))
                 endc: displ=((@.0)exc(@.0xF))
              ends
              endc:displ=((@.0)exc(@.1))
           ends
           endc:displ=((@.0)exc(@.1.V))
        ends
        endc:displ=((@.0)exc(@.1.V))
     ends
     endc:displ=((@.0)exc(@.1.V))
  ends:displ=('#',@.V):let Val=(@.V.0)exc((@.V.1.V.0)exc
      ((@.V.1.V.1.V.0)exc((@.V.1.V.1.V.1.V.0)exc
      (@.V.1.V.1.V.1.V.1.V/*4.0*/.0))));
*/

/*
TFileTime struc pas
  S: num+(5)
  M: num+(6)
  H: num+(5)
  D: num+(5)
  Mon: num+(4)
  Y: num+(7)
ends:displ=(INT(@.D),'.',INT(@.Mon),'.',INT(@.Y+1980),' ',
      INT(@.H),':',INT(@.M),':',INT(@.S*2))
*/

type    
  TNDXB1d TNDXB1():let Val=@.@:Val;:displ=(INT(@.@:Val)) //decimal representation


%$IF IsDelphi;

include DOSFTime.rfi

%$ELSE

include UNIXTime.rfi

type

TFileTime TTimeStamp

%$END

type

%$IF (Ver>=12)and IsDelphi; 
TNameStr struc pas
  L: byte
  LL: case @.L of
    0xFF: ulong
   endc
  S: array[(@.LL.0xFF)exc @.L]of char
ends: displ=(@.S)
%$ELSE
TNameStr str
%$END


TDCU30ListC forward

TSrcInf struc pas
  FT: TFileTime
  B: TNDXB1
%$IF MSIL;
  path: str
%$END
ends

%$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
TAssemblySrcInf struc pas
  FT: TFileTime
  B: TNDXB1
ends 
%$END

%$IF (Ver>7)and IsDelphi;
TResInf struc pas
  FT: TFileTime
  B: TNDXB1
ends
%$ELSE
TResInf TSrcInf
%$END

TUnitInf struc pas
 %$IF (Ver>=8)and IsDelphi;
  hPack: TNDXB1
 %$END
 %$IF (Ver>=10)and IsDelphi;
  Inf: TNDXB1
 %$ELSE
  Inf: ulong
 %$END
%$IF (Ver=7)and IsDelphi;
  X: ulong
//%$ELSIF (Ver>=8)and IsDelphi;
//  X: byte
%$END
 %$IF (Ver>=12)and IsDelphi;
  X: TNDXB1
 %$END
  L: TDCU30ListC
ends

%$IF (Ver>=13)and IsDelphi;
TUnitInlineSrcInf struc pas
  Inf: ulong
  B: TNDXB1 //Source number
ends
%$END

%$IF (Ver>=8)and IsDelphi;
TDLLInf struc pas
 %$IF (Ver>=10)and IsDelphi;
  Inf: TNDXB1
 %$ELSE
  Inf: ulong
 %$END
  X: ulong
 %$IF (Ver>=12)and IsDelphi;
  X: TNDXB1 //analogously to TUnitInf b0: Byte
 %$END
  L: TDCU30ListC
ends
%$ELSE
  TDLLInf TUnitInf
%$END


TImpTypeDefInf struc pas
  RTTISz: TNDXB1//L: Byte
  Inf: ulong
ends

TExportInf struc pas
  hSym: TNDXB1
  Index: TNDXB1
ends

TNameFDeclBase(NoInf) struc pas
  B: TNDXB1
%$IF (Ver>=8)and IsDelphi;
  B1: TNDXB1
%$END
 %$IF (Ver>=12)and IsDelphi;
  B3: TNDXB1
 %$END
  Inf: case (@:NoInf xor 1)*(@.B:Val and 0x40) of
    0x40: ulong
  endc
/*%$IF Packaged and(Ver>=3);
  PkgNdx: case @.B:Val and PkgNdxFlag of
    PkgNdxFlag: TNDXB1
  endc
%$END*/
%$IF (Ver>=8)and IsDelphi;
  B2: case @.B1:Val and 0x80 of
    0x80: struc pas
       X: TNDXB1 //Base type for defs like TX = type TY
        //when TX and TY both in the same unit,
        //earlier versions were just duplicating definitions
 %$IF (Ver=8)and IsDelphi;
       Z: case @@@.B:Val and 0x08 of
        0x08: TNDXB1 //always 0
       endc
 %$END
     ends
  endc
%$END
ends

TNameFDecl TNameFDeclBase(0)

TTypeInf(NoInf) struc pas
  NF: TNameFDeclBase(@:NoInf)
  hDef: TNDXB1
%$IF Packaged and((Ver>=3)and(Ver<=8)or(Ver>=100));
  PkgNdx: case @.NF.B:Val and PkgNdxFlag of
    PkgNdxFlag: TNDXB1
  endc
%$END
ends

TTypePInf struc pas
  NF: TNameFDecl
  hDef: TNDXB1
//  B1: Byte
  B1: TNDXB1
%$IF Packaged and((Ver>=3)and(Ver<=8)or(Ver>=100));
  PkgNdx: case @.NF.B:Val and PkgNdxFlag of
    PkgNdxFlag: TNDXB1
  endc
%$END
ends

TVarInf struc pas
  NF: TNameFDecl
  hDT: TNDXB1
  Ofs: TNDXB1 //hDT: TNDXB1 //B0: Byte
%$IF Packaged and((Ver>=3)and(Ver<=8)or(Ver>=100));
  PkgNdx: case @.NF.B:Val and PkgNdxFlag of
    PkgNdxFlag: TNDXB1
  endc
%$END
ends

%$IF Packaged;
TResStrDef struc pas
  NF: TNameFDecl
  hDT: TNDXB1
  Ofs: TNDXB1 //hDT: TNDXB1 //B0: Byte
%$IF Packaged and((Ver>=3)and(Ver<=8)or(Ver>=100));
  PkgNdx: case @.NF.B:Val and PkgNdxFlag of
    PkgNdxFlag: TNDXB1
  endc
%$END
ends
%$ELSE     
TResStrDef TVarInf
%$END

%$IF (Ver>=15)and IsDelphi /*and mode64*/;
TConstVal(Kind) struc pas
  Sz: TNDXB1
  Val: case (@.Sz.b1.V)exc 1 of
    0: case @@:Kind of
      4: void
     else TNDXB1
     endc
  else raw[@@.Sz:Val]
  endc
ends
%$ELSE
TConstVal struc pas
  Sz: TNDXB1
  Val: case (@.Sz.b1.V)exc 1 of
    0: TNDXB1
  else raw[@@.Sz:Val]
  endc
ends
%$END

TConstDef struc pas
  NF: TNameFDecl
  //Inf: ulong
  hDT: TNDXB1
%$IF Ver>4;
  Kind: TNDXB1 //O - scalar, 1 - string (offset=8), 2 - resourcestring,
               //3-float, 4 - set,
               //[ver>=verD12] 5 - Unicode string (offset=12)
               //for 64-bit mode 4 means pointer
%$END
%$IF (Ver>=15)and IsDelphi /*and mode64*/;
  Val: TConstVal(@.Kind:Val)
%$ELSE
  Val: TConstVal
%$END
ends

%$IF (Ver>=22)and IsDelphi;
TDependencyInfoItem struc pas
  Z: Byte
  sName: Str
  W: Word
  Ndx: TNDXB1
  L: TNDXB1
  Tbl: array[@.L:val]of TNDXB1
ends

TDependencyInfoRec struc pas
  Cnt: TNDXB1
  Items: array[@.Cnt:val]of TDependencyInfoItem
ends
%$END
/*
TResStrDef struc pas
  b80: Byte
  Inf: case @.b80 and 0x80 of
    0x80: ulong
  endc
  hDT: TNDXB1
  Ofs: TNDXB1
/*
  NDX1: TNDXB1
  B1: Byte
  B2: Byte
  V: TNDXB1
  Val: TConstVal
*/
ends
*/

TProcArgTag enum TDCU30RecTag of (
  arStop='c',
  arVal='!',
  arVar='"',
  arResult='#',
  arAbsLocVar='$',
  arLabel='+',
  arLocVar=0x20,//' ',
  arConst=0x25, //'%',
  arLocType='*',
  arEmbeddedProcEnd='k', //For Ver 5.0
//Fields
  arFld=',',
 %$IF (Ver>=10)and IsDelphi;
  arClassVar='-',
  arMethod='.',
  arConstr='/',
  arDestr='0',
  arProperty='1',
 %$ELSE
  arMethod='-',
  arConstr='.',
  arDestr='/',
  arProperty='0',
 %$END
  arCDecl=0x81,
  arPascal=0x82,
  arStdCall=0x83,
  arSafeCall=0x84,
%$IF (Ver>=10)and IsDelphi;
  arCopyDecl=0xA3,
%$END
%$IF (Ver>=13)and IsDelphi;
  arAnonymousBlock=0x01,
%$END
 %$IF (Ver>=16)and IsDelphi;
  arFinalFlag=0xC2,
 %$END
  arSetDeft=0x9A //Set Default parameter value
)

TPropInfo struc pas
  Flags: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
  FlagsEx: TNDXB1 //For Ver>=8 public=0x1,protected=0x2,published=0x5,class=0x10
 %$END
 %$IF (Ver>=12)and IsDelphi;
  X4: TNDXB1
 %$END
  hDT: TNDXB1
  Ndx: TNDXB1
  hIndex: TNDXB1 //property index
/*  D0Fl0: ulong
  B80: Byte */
  hRead: TNDXB1
  hWrite: TNDXB1
  hStored: TNDXB1
/*  D0Fl1: ulong
  B80a: Byte */
 %$IF (Ver>=8)and IsDelphi;
 //It looks like the next two fields contain references
 //to the class members specified in Pascal source for read and
 //write when compiler had to change calling convention or something else,
 //and hRead or hWrite point to the thunk methods created by the compiler
  hReadOrig: TNDXB1
  hWriteOrig: TNDXB1
 %$IF MSIL;
  X2: TNDXB1
  X3: TNDXB1
 %$END
 %$END
  hDeft: TNDXB1
ends

TSetDeftInfo struc pas
  hConst: TNDXB1
  hArg: TNDXB1
/*  sdB0: Byte
  sdB1: Byte
  sdB2: Byte
  sdB3: Byte
*/
ends

//%$IF (Ver>=7)and IsDelphi;
%$IF gen7;

%$IF (Ver>=8)and IsDelphi;

TConstAddInfo01Rec struc pas
  hDef: TNDXB1
  V: TNDXB1
  Len: TNDXB1
  SD: case @.Len:Val>0 of
    1: struc pas
      Name: array[@@@.Len:Val]of Char
      Cnt: TNDXB1
      Defs: array[@.Cnt:Val] of TNDXB1
     ends
   endc
ends

TStrNDXB1 struc pas
  Len: TNDXB1
  V: array[@.Len:Val]of Char
ends


TConstAddInfo0A_7Rec struc pas
  Name: TStrNDXB1
  V: TNDXB1
  V1: TNDXB1
  hDT: TNDXB1
ends

TInlineOpNDX TNDXB1():displ=(case (@.@:Val and 1)-(@.@:Val=0) of
-1:('-')
0:('@',INT(@.@:Val div 2-1))//Command index
else ('v',INT(@.@:Val div 2))
endc)

%$IF (Ver>=9)and IsDelphi;                        
const        
 %$IF Ver=9;
  inline_0=0x19;
 %$ELSIF Ver<=19;
  inline_0=0x1B;
 %$ELSE
  inline_0=0x20;
 %$END

type     
TInlineOpCode enum byte of (
 //The codes in comments are from D2005
  NOP=inline_0/*0x19*/, //end try or catch block in try ... finally and try ... except| raise; argument| may be NOP
  PutConst/*=0x1A*/,
  LeaC/*=0x1B*/,
  PutField/*=0x1C*/,
  ?,
  Lea/*=0x1E*/,
  PutStr/*=0x1F*/, //and functions to function variables
  ArgList/*=0x20*/,
  Let/*=0x21*/,
  LetF/*=0x22*/, //F - Float
  LetShortStr/*=0x23*/, //ShortString
  LetSet/*=0x24*/, //set of ..., Variant
  LetStr/*=0x25*/,
  LetIntf/*=0x26*/,
 %$IF Mobile and(Ver<20);
  LetCast,
 %$END
  LetDynArray/*=0x27*/,
  Add/*=0x28*/,
  Sub/*=0x29*/,
  Mul/*=0x2A*/,
  Div_/*=0x2B*/,
  Mod_/*=0x2C*/,
  AndB/*=0x2D*/,
  OrB/*=0x2E*/,
  XorB/*=0x2F*/,
  Shl_/*=0x30*/,
  Shr_/*=0x31*/,
  Inc/*=0x32*/,
  Dec/*=0x33*/,
  ?/*=0x34*/,
  ?/*=0x35*/,
  ?/*=0x36*/,
  ?/*=0x37*/,
  ?/*=0x38*/,
  ?/*=0x39*/,
  ?/*=0x3A*/,
  ?/*=0x3B*/,
  ?/*=0x3C*/,
  ?/*=0x3D*/,
  Neg/*=0x3E*/,
  NotB/*=0x3F*/,
  ?/*=0x40*/,
  ?/*=0x41*/,
  ?/*=0x42*/,
  LetI64/*=0x43*/,
  AddI64/*=0x44*/,
  SubI64/*=0x45*/,
  MulI64/*=0x46*/,
  DivI64/*=0x47*/,
  ModI64/*=0x48*/,
  AndBI64/*=0x49*/,
  OrBI64/*=0x4A*/,
  XorBI64/*=0x4B*/,
  ShlI64/*=0x4C*/,
  ShrI64/*=0x4D*/,
 %$IF Ver>=21;
  LetCvtPtr1/*=4E*/, //Perhapse it is LetCvtPtr
 %$ELSE
  ?/*=4E*/,
 %$END
  ?/*=4F*/,
  ?/*=50*/,
  ?/*=51*/,
  ?/*=52*/,
  ?/*=53*/,
  ?/*=54*/,
  ?/*=55*/,
  ?/*=56*/,
  ?/*=57*/,
  ?/*=58*/,
  ?/*=59*/,
  NegI64/*=0x5A*/,
  NotBI64/*=0x5B*/,
  CmpEQi64/*=0x5C*/,
  CmpNEi64/*=0x5D*/,
  CmpLTi64/*=0x5E*/,
  CmpLEi64/*=0x5F*/,
  CmpGTi64/*=0x60*/,
  CmpGEi64/*=0x61*/,
  AddF/*=0x62*/,
  SubF/*=0x63*/,
  MulF/*=0x64*/,
  DivF/*=0x65*/, //A/B for Int64 and Float
 %$IF Ver>=20;
  ?,
 %$END
  NegF/*=0x66*/,
 %$IF Ver>=20;
  ?,
 %$END
  ?/*=0x67*/,
  ?/*=0x68*/,
  ?/*=0x69*/,
  ?/*=0x6A*/,
  ?/*=0x6B*/,
  ?/*=0x6C*/,
  And_/*=0x6D*/,
  Or_/*=0x6E*/,
  Not_/*=0x6F*/,
  CmpEQ/*=0x70*/,
  CmpNE/*=0x71*/,
  CmpLT/*=0x72*/,
  CmpLE/*=0x73*/,
  CmpGT/*=0x74*/,
  CmpGE/*=0x75*/,
  CmpEQF/*=0x76*/, //Float
  CmpNEF/*=0x77*/, //
  CmpLTF/*=0x78*/, //
  CmpLEF/*=0x79*/, //
  CmpGTF/*=0x7A*/, //
  CmpGEF/*=0x7B*/, //
  CmpEqSet/*=0x7C*/, //set of
  CmpNESet/*=0x7D*/,
  CmpLESet/*=0x7E*/,
  CmtGESet/*=0x7F*/,
  CmpEQShortS/*=0x80*/, //ShortString
  CmpNEShortS/*=0x81*/, //
  CmpLTShortS/*=0x82*/, //
  CmpLEShortS/*=0x83*/, //
  CmpGTShortS/*=0x84*/, //
  CmpGEShortS/*=0x85*/, //
  CmpEQS/*=0x86*/, //String
  CmpNES/*=0x87*/, //
  CmpLTS/*=0x88*/, //
  CmpLES/*=0x89*/, //
  CmpGTS/*=0x8A*/, //
  CmpGES/*=0x8B*/, //
  InSet/*=0x8C*/,
  SetIntersect/*=0x8D*/,
  SetUnion/*=0x8E*/,
  SetDiff/*=0x8F*/,
  SetForElt/*=0x90*/,
  SetForRange/*=0x91*/,
  ShortStrCat/*=0x92*/,
  StrCat/*=0x93*/,
  AddVar/*=0x94*/, //Variant
  SubVar/*=0x95*/, //
  MulVar/*=0x96*/, //
  DivVar/*=0x97*/, // div operator
  ModVar/*=0x98*/, //
  AndVar/*=0x99*/, //
  OrVar/*=0x9A*/, //
  XorVar/*=0x9B*/, //
  ShlVar/*=0x9C*/, //
  ShrVar/*=0x9D*/, //
  NegVar/*=0x9E*/, //
  NotVar/*=0x9F*/, //
  DivideVar/*=0xA0*/,// / operator
  CmpEQVar/*=0xA1*/, //Variant
  CmpNEVar/*=0xA2*/, //
  CmpLTVar/*=0xA3*/, //
  CmpLEVar/*=0xA4*/, //
  CmpGTVar/*=0xA5*/, //
  CmpGEVar/*=0xA6*/, //
  ?/*=0xA7*/,
  ?/*=0xA8*/,
  CallInt/*=0xA9*/,
  CallFloat/*=0xAA*/, //Procedures, methods
  PutArg/*=0xAB*/,
  CallFnAsProc/*=0xAC*/, //Int
  CallFnAsProcFile/*=0xAD*/, //For write, which returns TextFile
  Block/*=0xAE*/,
  IfT/*=0xAF*/, //If then
  IfTE/*=0xB0*/, //If then else
  While_/*=0xB1*/,
  Repeat/*=0xB2*/,
  Case_/*=0xB3*/,
  For_/*=0xB4*/,
  GoTo/*=0xB5*/,
  SetLabel/*=0xB6*/,
  CvtT/*=0xB7*/,
  Cond/*=0xB8*/,
  ChkRange/*=0xB9*/,
  Include_/*=0xBA*/,
  Exclude_/*=0xBB*/,
  Break_/*=0xBC*/,
  Continue_/*=0xBD*/,
  Exit/*=0xBE*/,
  ?/*=0xBF*/,
  Raise/*=0xC0*/,
  TryExcept/*=0xC1*/,
  TryFinally/*=0xC2*/,
  TryCase/*=0xC3*/,
  ObjIs/*=0xC4*/,
  ObjAs/*=0xC5*/,
  OpenArrayArg/*=0xC6*/,
  ForIn/*=0xC7*/,
  LetCvtPtrSArg/*=0xC8*/,
  ?/*=0xC9*/,
  ?/*=0xCA*/,
  ?/*=0xCB*/,
  ?/*=0xCC*/,
  ?/*=0xCD*/,
  PutClass/*=0xCE*/
  CvtIntDT/*=0xCF*/,
  ?/*=0xD0*/,
  ?/*=0xD1*/,
 %$IF Ver>=20;
  ?,?
 %$END
  LetT/*=0xD2*/, //in templates
  MemberT/*=0xD3*/, //in templates
 %$IF Ver>=20;
  ?
 %$END
  OpenArrayElT/*=0xD4*/, //in templates
  ?/*=0xD5*/
  ?/*=0xD6*/
 %$IF Ver>=13;
  ,CvtIntfToCl/*=0xD7*/ //Interface to Class
  %$IF Ver>=18;
  ,CvtTToClass/*=0xD8*/
  %$IF Ver>=22;
  ,CvtAuxIntfToClass/*=0xD9*/
  %$END
  %$END
 %$END
 %$IF Mobile and(Ver>=20);
  ,LetCast=0xE7
 %$END
 %$IF Ver>=21;
  ,LetCvtPtr=0xEA
  ,CvtConst=0xEB
 %$END
 %$IF Ver>=24;
  ,InlineFCall=0xEC //When some complex inline function (several operators) is called from an expression (was observed in the call of Length() from the ForIn)
 %$END
)       

%$IF Ver>=12;
%$IF Ver>=21;
TLineIndex(W) case @:W and 0x1000<>0 of
 0: ulong
endc
%$ELSE;
TLineIndex ulong //The index of the line in the tables Lines.
  //It looks like some dummy have added this field without any idea about indices (TNDXB1)
%$END
%$END

%$IF Ver>20;
TInt64 struc pas
  Lo: TNDXB1
  Hi: TNDXB1
ends:displ=('$',@.Hi,HEX(@.Lo:Val,8))

TInlineConstKind enum byte of (
 //The other values were not encountered yet
  cInt=1,
  cUInt=2,
  cInt64=3,
  cUInt64=4,
  cFloat=7,
  cStr=8,
  cSet=0xC,
  c1=0x10/*1*/,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,
  c_1=0x20/*-1L*/,c_2,c_3,c_4,c_5,c_6,c_7,c_8,c_9,c_10,c_11,c_12,c_13,c_14,c_15,c_16,
  c1L=0x30/*1*/,c2L,c3L,c4L,c5L,c6L,c7L,c8L,c9L,c10L,c11L,c12L,c13L,c14L,c15L,c16L, /*All 64-bit*/
  c_1L=0x40/*-1L*/,c_2L,c_3L,c_4L,c_5L,c_6L,c_7L,c_8L,c_9L,c_10L,c_11L,c_12L,c_13L,c_14L,c_15L,c_16L,
  c0=0x50,c0L=0x51/*64-bit*/,c0Float,c1Float
)        

TInlineStrConst struc pas
  Sz: TNDXB1
  D: raw[@.Sz:Val]
ends     

TInlineSet  struc pas
  Sz: TNDXB1
  Base: TNDXB1 //?
  D: raw[@.Sz:Val]
ends     

TInlineConst struc pas
  Kind: TInlineConstKind
  V: case @.Kind of
   cInt,cUInt: TNDXB1
   cInt64,cUInt64: TInt64
   cFloat: TExtended
   cStr: TInlineStrConst
   cSet: TInlineSet
  endc
ends
%$END

TInlineOp struc pas
  Op: TInlineOpCode
  W: Word
  hDT: TNDXB1 //Index in Types
  Args: case @.Op of
  %$IF Ver<=20;
   PutConst: struc pas
     C: TNDXB1 //In fact it can be Extended for floats and so on,
     //but it is required to use the hDT data type info to determine the value type
     /*C: case @.Kind:Val of
       1: TExtended
       2: TNDXB1
     endc*/
    ends
  %$ELSE
   PutConst: TInlineConst
  %$END
   PutStr,PutClass: struc pas
     hVar: TInlineOpNDX
    ends
   LeaC: struc pas
     Ofs: TNDXB1
    %$IF mode64;
     GlobBase: TInlineOpNDX
    %$END
     Base: TInlineOpNDX
    ends
   Lea: struc pas //Result := Base+Index shl Shift
     Ofs: TNDXB1
    %$IF mode64;
     GlobBase: TInlineOpNDX
    %$END
     Base: TInlineOpNDX
     Index: TInlineOpNDX
     Shift: TNDXB1
    ends
   PutArg: struc pas
     hArg: TInlineOpNDX
    ends
   Block: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Cnt: TNDXB1
     Args: array[@.Cnt:Val]of TInlineOpNDX
    ends
   IfT: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Cond: TInlineOpNDX
     Then_: TInlineOpNDX
    ends
   IfTE: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Cond: TInlineOpNDX
     Then_: TInlineOpNDX
     Else_: TInlineOpNDX
    ends
   Case_: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Expr: TInlineOpNDX
     Cnt: TNDXB1 //Case count
     Code: array[@.Cnt:Val]of TInlineOpNDX //The operators for the cases
     ICnt: TNDXB1 //Interval count
     Intervals: array[@.ICnt:Val]of struc pas
       S: TNDXB1
       E: TNDXB1
       hCode: TNDXB1
      ends
     Else_: TInlineOpNDX
    ends
   Repeat: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Cond: TInlineOpNDX
     Body: TInlineOpNDX
    ends
   For_: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Z0: TNDXB1
     Z1: TNDXB1
     hVar: TInlineOpNDX
     hB: TInlineOpNDX
     hFrom: TInlineOpNDX
     hTo: TInlineOpNDX
     Z2: TNDXB1
     hBody: TInlineOpNDX
     hStep: TInlineOpNDX
    ends
   ForIn: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     Z0: TNDXB1
     Z1: TNDXB1
     hCond: TInlineOpNDX
     hBody: TInlineOpNDX
     hStep: TInlineOpNDX
    ends
   While_: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hCond: TInlineOpNDX
     hBody: TInlineOpNDX
    ends
   Break_,Continue_: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     nTarget: TNDXB1d
     B0: Byte //Proof: XE5, REST.JsonReflect.dcu, TTypeMarshaller`1.MarshalData,
     Z1: TNDXB1
     Z2: TNDXB1
     /*Z2: case @.nTarget:Val<@@@:# of
      0: TNDXB1
      endc*/
    ends
   Exit,NOP: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
    ends
   TryFinally: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hTry: TInlineOpNDX
     hFinally: TInlineOpNDX
    ends
   TryExcept: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hTry: TInlineOpNDX
     hExcept: TInlineOpNDX
    ends
   TryCase: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hCode: TInlineOpNDX
     hNext: TInlineOpNDX
     hExcVar: TInlineOpNDX //The variable for the exception
     hExcType: TNDXB1
    ends
   Raise: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hCode: TInlineOpNDX //NOP for reraise
    %$IF Ver>=14;
     AtAddr: TInlineOpNDX
    %$END
    ends
  %$IF Mobile;
   LetCast,
  %$END
  %$IF Ver>=21;
   LetCvtPtr,
   %$IF Ver>=21;
    LetCvtPtr1,
   %$END
  %$END
   Let,LetI64,LetF,LetShortStr,LetStr,LetSet,LetIntf,LetDynArray,LetT,LetCvtPtrSArg: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hDest: TInlineOpNDX
     hSrc: TInlineOpNDX
    ends
   ArgList,OpenArrayArg: struc pas
     hArg: TInlineOpNDX
     hNext: TInlineOpNDX
    ends
   NegF: struc pas
     hArg: TInlineOpNDX
    %$IF Ver=9;
     hArg2: TInlineOpNDX/*For some error they had two arguments in D2005*/
    %$END
    ends
   NegVar,NotVar,ChkRange: struc pas
     hArg: TInlineOpNDX
     hArg2: TInlineOpNDX/*For some error they had two arguments too*/
    ends
   Inc,Dec,Include_,Exclude_: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hArg1: TInlineOpNDX
     hArg2: TInlineOpNDX
    ends
   Add,Sub,Mul,Div_,Mod_,
   Shl_,Shr_,AndB,OrB,XorB,And_,Or_,
   AddI64,SubI64,MulI64,DivI64,ModI64,DivF,
   AndBI64,OrBI64,XorBI64,ShlI64,ShrI64,
   AddF,SubF,MulF,
   CmpEQ,CmpNE,CmpLT,CmpLE,CmpGT,CmpGE,
   CmpEQi64,CmpNEi64,CmpLTi64,CmpLEi64,CmpGTi64,CmpGEi64,
   CmpEQF,CmpNEF,CmpLTF,CmpLEF,CmpGTF,CmpGEF,
   CmpEQS,CmpNES,CmpLTS,CmpLES,CmpGTS,CmpGES,
   CmpEQShortS,CmpNEShortS,CmpLTShortS,CmpLEShortS,CmpGTShortS,CmpGEShortS,
   CmpEQVar,CmpNEVar,CmpLTVar,CmpLEVar,CmpGTVar,CmpGEVar,
   CmpEQSet,CmpNESet,CmpLESet,CmtGESet,
   InSet,SetUnion,SetIntersect,SetDiff,
   AddVar,SubVar,MulVar,DivVar,ModVar,AndVar,OrVar,XorVar,
   ShlVar,ShrVar,DivideVar,
   ShortStrCat,StrCat,OpenArrayElT,CvtIntDT: struc pas
     hArg1: TInlineOpNDX
     hArg2: TInlineOpNDX
    ends
   Cond,CallFnAsProc,CallFnAsProcFile,SetLabel,GoTo: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hArg: TInlineOpNDX
    ends
  %$IF Ver>=24;
   InlineFCall: struc pas
     nLine: TLineIndex(@@@.W)
     hOp: TInlineOpNDX //Operator to execute before expressions
     hVal: TInlineOpNDX //the expression (condition) itself
    ends
  %$END
  %$IF Ver>=18;
   CvtTToClass,
  %$IF Ver>=22;
   CvtAuxIntfToClass,
  %$END
  %$END
  %$IF Ver>=21;
   CvtConst,
  %$END
   Not_,Neg,NotB,NotBI64,NegI64: struc pas
     hArg: TInlineOpNDX
    ends
   /*CallProc,*/CallInt,CallFloat: struc pas
    %$IF Ver>=21;
     nLine: TLineIndex(@@@.W)
    %$ELSIF Ver>=12;
     nLine: TLineIndex
    %$END
     hFunc: TInlineOpNDX
     hArgs: TInlineOpNDX
     //F: TInlineOpNDX
    ends
   SetForElt,SetForRange: struc pas
     hElt: TInlineOpNDX
     hElt1: TInlineOpNDX //0 for SetForElt
    ends
   ObjIs,ObjAs: struc pas
     hObj: TInlineOpNDX
     hCl: TInlineOpNDX
    ends
 %$IF Ver>=13;
   CvtIntfToCl: struc pas
     hCl: TInlineOpNDX
     hIntf: TInlineOpNDX
    ends
 %$END
   CvtT: struc pas
     hDest: TInlineOpNDX //Unnamed, always addr with hAddr=0
     hSrc: TInlineOpNDX
    ends
   PutField: struc pas
     Ofs: TNDXB1
    %$IF mode64;
     GlobBase: TInlineOpNDX
    %$END
     hObj: TInlineOpNDX
    ends
   MemberT: struc pas
     hObj: TInlineOpNDX
     hType: TInlineOpNDX
    ends
  endc
ends:displ=(INT(@:#)/*,':',HEX(&@-&@:@)*//*ADDR(&@)*/,': ',valname(@.Op),' ',HEX(@.W,4),', hDT:',@.hDT,' ',@.Args)

TInlineCode(Sz) struc pas
  Codes: array of TInlineOp?(&@-&@:@>=(@:@:@ as TInlineCode):Sz)or not HasEnumName(@.Op,TInlineOpCode)!void;:displ=(ShowArray(@,(NL,@)),NL)
  rest: raw[]
ends:[@:Size=@:Sz]
%$ELSE         
TInlineCode(Sz) raw[@:Sz]
%$END

const
%$IF (Ver>=12)and IsDelphi;
  cafInline=0x40000;
  cafBigVal=0x80000;
%$ELSE
  cafInline=0x80000;
  cafBigVal=0x100000;
%$END

type

TConstAddInfoRec struc pas
  Tag: Byte
  D: case @.Tag of
   0x01: struc pas
     hDef: TNDXB1
     F: TNDXB1 //$1-deprecated,$2-Platform,$80000-Inline
     %$IF (Ver>=10)and(Ver<23)and IsDelphi and(iOs=0);
     IP1: case @.F:Val and 0x1000000 of
      0x1000000: TNDXB1 //Some int(4)
     endc
     %$END
    %$IF MSIL; //and(Ver<=9);
     %$IF (Ver>=9)and IsDelphi;
     IP2: case @.F:Val and 0x10000 of
      0x10000: struc pas
         L: TNDXB1
         sCSharp: array[@.L:Val]of Char
       ends
     endc
     %$END
     Cnt: TNDXB1
     Tbl: array[@.Cnt:Val] of TConstAddInfo01Rec
    %$END
    /**/
    %$IF (Ver>=9)and IsDelphi;
     %$IF (Ver>=12)and IsDelphi;
      hUsedCl: case @.F:Val and 0x800000/*0x840000*/ of
       0x800000: TNDXB1 ////Class reference, when 0x40000 already in Inline
        //Since D2010 it is generated for attributes and contains the attribute class type reference
        //The attribute constructor and its parameters are missing and can be found in RTTI memory only
        //until D_XE6, when the 0x80000000 flag had been introduced
      endc
     %$END
     %$IF (Ver>=12)and IsDelphi;
      Deprecated: case @.F:Val and 0x1 of
       0x1: TStrNDXB1
      endc
     %$END
     %$IF (Ver>=19)and IsDelphi;
      Attribute: case @.F:Val and 0x80000000=0 of
       0: struc pas
         N: TNDXB1 //Attribute count
         Attrs: array[@.N:Val] of struc pas
           hAttrCtor: TNDXB1 //Attribute constructor
           MemberKind: TNDXB1 //[Result: Unsafe] Result=#D
           hAttrDT: TNDXB1 //Attribute type
           ArgCnt: TNDXB1
           Args: array[@.ArgCnt:Val]of struc pas
             ArgKind: TNDXB1 //Argument Kind
             Arg: case @.ArgKind:Val of
              0: struc pas //const
                hArgT: TNDXB1 //Argument type
                Kind: TNDXB1 //Like that in TConstDecl
                  //(O - scalar, 1 - string (offset=8), 2 - resourcestring,
                  //3-float, 4 - set,
                  //[ver>=verD12] 5 - Unicode string
                Val: TConstVal(@.Kind:Val)
               ends
              1: struc pas //TypeInfo(DT)
                hDT: TNDXB1 //DT index in the type table
                hDTAddr: TNDXB1 //DT index in the addr table
               ends
             endc
            ends
          ends
        ends
      endc
     %$END
     Inline: case @.F:Val and cafInline of
      cafInline: struc pas
       %$IF (Ver>=10)and IsDelphi;
         Y: TNDXB1
         Y1: TNDXB1
        %$IF MSIL;
        // Y1: TNDXB1
        %$END
       %$END
        %$IF (Ver>=13)and IsDelphi;
        // DY: array[@.Y:Val]of TNDXB1
        %$END
         Sz: TNDXB1
         D: TInlineCode(@.Sz:Val)
         X0: TNDXB1
         X1: TNDXB1
        %$IF (Ver>=15)and IsDelphi;
         XX: TNDXB1
        %$END
         hRoot: TInlineOpNDX //The root node
         nRes: TInlineOpNDX //The number of result var
         X4: TNDXB1
         V2: TNDXB1 //Always 2=#1
         LenA: TNDXB1
        %$IF (Ver>=12)and IsDelphi;
         StartLine: TNDXB1 //The source line # of begin
         MaxLine: TNDXB1 //Max(Lines[i])+1
         //Y4: TNDXB1
         NLines: TNDXB1 //Number of source lines
         Lines: array[@.NLines:Val]of long //the lines (<0 => -absolute line number, else relative line number (from prev. absolute))
        %$END
         Addrs: array[@.LenA:Val]of struc pas
         %$IF (Ver<12)and IsDelphi;
           F: TNDXB1
           D: case @.F:Val of
             0: struc pas
               hAddr: TNDXB1 //Address index of parameter, procedure, or data type used
               hMember: TNDXB1 //The ordinal number of class member
              ends
            else struc pas
              hDT: TNDXB1 //The unit type index of the anonymous variable
             ends
            endc
         %$ELSE
           hAddr: TNDXB1 //Address index of parameter, procedure, or data type used
           hDT: TNDXB1 //The index in types
           hMember: TNDXB1 //The ordinal number of class member
         %$END
         %$IF (Ver>=12)and IsDelphi;
           Y1: TNDXB1
           CntR: TNDXB1
          %$IF (Ver>=13)and IsDelphi;
           N: TNDXB1
          %$END
           /*R: case @.Z:Val<>0 of
            1: TNDXB1
           endc*/
           R: array[@.CntR:Val]of TNDXB1
         %$END
          ends
         LenT: TNDXB1
         Types: array[@.LenT:Val/*when (@.Len2:Val<200)exc 0*/]of struc pas
           Kind: TNDXB1
          %$IF (Ver>=12)and IsDelphi;
          /*
           V: array[@.LF:Val div 2]of TNDXB1
           C: case @.LF:Val and 1 of
            1: struc pas //!!!
               N1: TNDXB1
               N2: TNDXB1
             ends
           endc*/
          %$END
           C: case @.Kind:Val of
           %$IF (Ver>=12)and IsDelphi;
            1: struc pas
               N1: TNDXB1
               N2: TNDXB1
              %$IF (Ver>=14);
               N3: TNDXB1
              %$END
             ends
            2: struc pas
               hType: TNDXB1 //Data type index
             ends
            3: struc pas
              //%$IF (Ver<14);
               N1: TNDXB1
               N2: TNDXB1
               N3: TNDXB1
              //%$END
             ends
            4: struc pas
               N1: TNDXB1
               N2: TNDXB1
             ends
            5: struc pas
               N1: TNDXB1
               N2: TNDXB1
               N3: TNDXB1
               N4: TNDXB1
             ends
            6: struc pas //Ver13 only
              %$IF (Ver>=23)and IsDelphi;
               N0: TNDXB1
              %$END
               N1: TNDXB1
               /*N2: TNDXB1
               N3: TNDXB1
               N4: TNDXB1
               N5: TNDXB1*/
             ends
            7: struc pas //Ve1
              %$IF (Ver>=23)and IsDelphi;
               N0: TNDXB1
              %$END
               N1: TNDXB1
             ends
           %$ELSE
            1: struc pas
               N1: TNDXB1
               N2: TNDXB1
               N3: TNDXB1
             ends
            else TNDXB1
           %$END
           endc
          ends
         NUnits: TNDXB1
         ImpData: array[@.NUnits:Val/*when (@.Len3:Val<100)exc 0*/]of struc pas
           hUnit: TNDXB1
           Len: TNDXB1
           D: array[@.Len:Val/*when (@.Len:Val<100)exc 0*/]of TNDXB1 //Imported def
          ends
        %$IF (Ver>=10)and IsDelphi;
         Len4: TNDXB1
         Data4: array[@.Len4:Val/*when (@.Len4:Val<100)exc 0*/]of TNDXB1
        %$IF (Ver>=12)and IsDelphi;
         V0: TNDXB1
         V1: TNDXB1
         V2: TNDXB1
        %$END
        %$END
       /*
        %$IF (Ver>=12)and IsDelphi;
         Len4: TNDXB1
         Data4: array[@.Len4:Val/*when (@.Len4:Val<100)exc 0*/]of TNDXB1
         V0: TNDXB1
         V1: TNDXB1
         V2: TNDXB1
        %$END
        */
       /*
        %$IF (Ver>=10)and IsDelphi;
        //may be part of IP
         DeprecatedArgs: case @@@.F:Val and 0x100001 of
           0x1: struc pas
             LenArgsF: TNDXB1
             ArgsF: array[@.LenArgsF:Val]of TNDXB1
            ends
          endc
        %$END*/
       ends
     endc
    %$IF (Ver>=9)and IsDelphi;
     InfBig: case @.F:Val and cafBigVal of
      cafBigVal: TNDXB1 //Big value - 5 bytes
     endc
    %$END
    /*
    %$IF (Ver>=12)and IsDelphi;
     Inf80000: case @.F:Val and 0x80000 of
      0x80000: TNDXB1 //Big value - 5 bytes
     endc
    %$END
     IP: case @.F:Val and 0x100000 of
      0x100000: struc pas
       %$IF (Ver>=10)and IsDelphi;
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val] of TNDXB1
       %$END
        V: TNDXB1 //Some int(4-byte)
      ends
     endc
     */
/*1
     %$IF (Ver>=10)and IsDelphi;
     IP1: case @.F:Val and 0x1000000 of
      0x1000000: TNDXB1 //Some int(4)
     endc
     %$END
*/
    %$END
   /**/
    ends
   %$IF (Ver>=10)and IsDelphi;
   0x04: struc pas
     V: TNDXB1
     V1: TNDXB1
    ends
   %$END
   0x06: struc pas
     hDef: TNDXB1
     hDT: TNDXB1
     V: TNDXB1
     hDef1: TNDXB1
    ends
   0x07: struc pas
     hDef: TNDXB1
     hDef1: TNDXB1
     hDef2: TNDXB1
     V: TNDXB1
    ends
   0x09: struc pas
     hDef: TNDXB1
     hDT: TNDXB1
    ends
   0x0A: struc pas
     hDef: TNDXB1
     V: TNDXB1
     F: TNDXB1
     hDT: case @.F:Val and 0x1 of
      0x1: TNDXB1
     endc
     hDef1: case @.F:Val and 0x2 of
      0x2: TNDXB1
     endc
     V2: case @.F:Val and 0x4 of
      0x4: TNDXB1
     endc
     V3: case @.F:Val and 0x8 of
      0x8: TNDXB1
     endc
     V4: case @.F:Val and 0x10 of
      0x10: TNDXB1
     endc
     hDef5: case @.F:Val and 0x20 of
      0x20: TNDXB1
     endc
     inf7: case @.F:Val and 0x40 of
      0x40: struc pas
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val] of TConstAddInfo0A_7Rec
       ends
     endc
     inf8: case @.F:Val and 0x80 of
      0x80: struc pas
        V: TNDXB1
        V1: TNDXB1
        V2: TNDXB1
       ends
     endc
     sGenName: case @.F:Val and 0x100 of //The value in the generated code
      0x100: TStrNDXB1
     endc
     s10: case @.F:Val and 0x200 of
      0x200: TStrNDXB1
     endc
     hDef11: case @.F:Val and 0x400 of
      0x400: TNDXB1
     endc
     hDef12: case @.F:Val and 0x800 of
      0x800: TNDXB1
     endc
     hDef13: case @.F:Val and 0x1000 of
      0x1000: TNDXB1
     endc
     hDef14: case @.F:Val and 0x2000 of
      0x2000: TNDXB1
     endc
     hDef15: case @.F:Val and 0x4000 of
      0x4000: TNDXB1 //MSIL 9 only?
     endc
    ends
   0x0C: struc pas
     hDef: TNDXB1
     V1: TNDXB1
     V2: TNDXB1
    ends
  %$IF (Ver>=9)and IsDelphi;
   0x0D: struc pas
     hDef: TNDXB1
     S: TStrNDXB1
    ends
  %$END
  %$IF (Ver>=12)and IsDelphi;
   0x10: struc pas
     V0: TNDXB1
     V1: TNDXB1
     V2: TNDXB1
    ends
  %$IF (Ver>=17)and IsDelphi;
   0x11: struc pas
     hDef: TNDXB1
     V: TNDXB1
    ends
  %$END
   0x12: struc pas //appears for TX = type TY
     V0: TNDXB1
     V1: TNDXB1
    ends
   0x13: struc pas
     hAddr: TNDXB1
     V1: TNDXB1
     V2: TNDXB1
     ExtSym: TStrNDXB1 // $EXTERNALSYM
     ExtSym1: TStrNDXB1 //??
     ObjTN: TStrNDXB1 // $OBJTYPENAME
    ends
   0x14: struc pas //qualifier path for aux field
     //which is created now when property read/write/etc
     //references a field inside record
     V0: TNDXB1
     V1: TNDXB1
     Cnt: TNDXB1
     Tbl: array[@.Cnt:Val]of struc pas
       U0: TNDXB1
       U1: TNDXB1
       U2: TNDXB1
       Sym: TStrNDXB1
     ends
    ends
  %$END
  %$IF (Ver>=15)and IsDelphi;
   0x15: struc pas
     hDef: TNDXB1
     V0: TNDXB1
     V1: TNDXB1
    ends
  %$END
  endc
ends

%$IF (Ver>=15)and IsDelphi;
const
  caiStop=0x16;
%$ELSIF (Ver>=12)and IsDelphi;
const
  caiStop=0x15;
%$ELSIF (Ver>=9)and IsDelphi;
const
  caiStop=0x0F;
%$ELSE
const
  caiStop=0x0D;
%$END

%$ELSE
const
  caiStop=0x06;

type
TConstAddInfoRec struc pas //it`s easier to repeat it here than to hide all the tags of the higher versions
  Tag: Byte
  D: case @.Tag of
   0x01: struc pas
     hDef: TNDXB1
     F: TNDXB1 //$1-deprecated,$2-Platform - from the higher versions, may be wrong
    ends
  endc
ends
/* D7:DesignIDE.dcp@Designeditors.dcu shows that it`s a sequence too
TConstAddInfo struc pas
  B01: Byte
  Ndx: TNDXB1
  B02: Byte
  B06: Byte
ends
*/
%$END

type

TConstAddInfo array of TConstAddInfoRec ?@.Tag>=caiStop!byte; //= ==> Ok,> ==> Error

%$END

%$IF (Ver>=8)and IsDelphi;
 Tbyte1 byte():assert[@=1]
%$END

%$IF (Ver>=12)and IsDelphi;
/*
 TChar21 Char():assert[(@='!') //override
   or (@='a') //override abstract?
   or (@=' ') //static
 ]

 TOverloadF try
  Overload: TChar21
  None: void
 endt
*/
/*
 TInlineRec struc pas
  Tag: Byte
  V: TNDXB1
 ends:assert[(@.Tag=4/*Inline*/)or(@.Tag=2/*Class helpers*/)]

 TInlineZRec struc pas
  Tag: Byte
  B80: Byte //or 0
  B20: Byte
 ends:assert[(@.Tag=0)or(@.Tag=0x80)or(@.Tag=0x84)]

 TInlineF try
  Inline: TInlineRec
  Z: TInlineZRec
  None: void
 endt
*/

 TInlineF array of byte ?not((@=0x80)or(@=0x84)or
   (@=4)or(@=2)or(@=0x20)or(@=0)or(@=0x18)or
  %$IF (Ver>=13)and IsDelphi;
   (@=1)or
  %$END
  %$IF (Ver>=15)and IsDelphi;
   (@=0x38)or //& operator
   (@=0x28)or //&op_Equality in debug mode
  %$END
  %$IF (Ver>=16)and IsDelphi;
   (@=0x42)or
   (@=0x22)or
   (@=0x9)or //auto added from Helper
  %$END
  %$IF (Ver>=17)and IsDelphi and ARC;
   //in fact ARC support
   (@=0x47)or //unsafe
   (@=0x4F)or //unsafe virtual?
  %$END
  %$IF (Ver>=20)and IsDelphi;
   (@=0x60)or //static?
  %$END
  %$IF (Ver>=21)and IsDelphi;
   (@=0xA1)or //Method from helper
  %$END
  %$IF (Ver>=24)and IsDelphi;
   (@=0x7)or //Found in System.Net.Socket
   (@=0x41)or//
  %$END
   (@=8)or(@=0x10)or
  //from TOverloadF:
   (@='!') //override
   or (@='a') //override abstract?
   or (@=' ') //static
   )!void;

%$END

%$IF (Ver>=9)and(Ver<=10)and MSIL;
TAssemblyInfo struc pas
  Name: TStrNDXB1
ends
%$END

TProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag of
    arSetDeft: TSetDeftInfo
    arEmbeddedProcEnd: void //For Ver=5
//   %$IF (Ver>=7)and IsDelphi;
   %$IF gen7;
    TDCU30RecTag.drConstAddInfo: TConstAddInfo
   %$END
   %$IF (Ver>=7)and IsDelphi;
    TDCU30RecTag.drProcAddInfo: TNDXB1
   %$END
   %$IF (Ver>=20)and IsDelphi;
    TDCU30RecTag.drNextOverload: TNDXB1
   %$END
   %$IF (Ver>=8)and IsDelphi;
    TDCU30RecTag.drEmbeddedProcStart: void
   %$END
%$IF (Ver>=10)and IsDelphi;
    arCopyDecl: TNDXB1 //index of the address to copy from
  %$IF (Ver>=12)and IsDelphi;
   // arCopyDecl=TDCU30RecTag.arCopyDecl: TNDXB1
    TDCU30RecTag.drA5Info: struc pas
     // bA6: Byte;
     // X: TNDXB1
     ends
    TDCU30RecTag.drA6Info: TDCU30ListC //void
    TDCU30RecTag.drA7Info: struc pas
      V1: TNDXB1
      Len: TNDXB1
      Tbl: array[@.Len:Val]of TNDXB1
     ends
    TDCU30RecTag.drA8Info: TNDXB1
  %$END
  %$IF (Ver>=16)and IsDelphi;
    arFinalFlag: TNDXB1
  %$END
    0x80..0xA2,0xA4..0xFF: void
%$ELSE
    0x80..0xFF: void
%$END
   else struc pas
    Name: TNameStr
    D: case @@@.Tag of
      arLocType: TTypeInf(1)
      arProperty: TPropInfo
      arConst: TConstDef
      arLabel: struc pas
        Flags: TNDXB1
       %$IF (Ver>=8)and IsDelphi;
        FlagsEx: TNDXB1
       %$END
       %$IF (Ver>=12)and IsDelphi;
        B3: TNDXB1
       %$END
       ends
      arMethod: struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA, (for Ver<8)
          //default property=0x20,virtual=0x40,$80=dynamic, class=0x01
       %$IF (Ver>=8)and IsDelphi;
        FlagsEx: TNDXB1 //For Ver>=8 public=0x1,protected=0x2,published=0x5,class=0x10
       %$END
       %$IF (Ver>=12)and IsDelphi;
        B3: TNDXB1
       %$END
        hDT: TSNDXB1 //VMT index, dynamic index, for static methods - [last negative VMT index]-1
        Ndx: TNDXB1 //The addr of the method
       %$IF MSIL; //(Ver>=8)and IsDelphi;
        B1: case (@.Ndx.b1.V)exc 1 of
         0: void
         else
          try
           Is1:Tbyte1
           Els: void
          endt
         endc
       %$END
       %$IF (Ver>=7)and IsDelphi;
        %$IF Ver>=12;
        BF: case @@@.Name.L=0 of
         0: Byte
        endc
        //BF: Byte
        %$END
        hImp: TNDXB1
       %$ELSE
        hImp: case @@@.Name[0] of
         0: TNDXB1
        endc //for property P:X read Proc{Implemented in parent class}
       %$END
       %$IF (Ver>=12)and IsDelphi;
//        %$IF (Ver>=13)and IsDelphi;
//         ClassF: case @.FlagsEx:Val and 0x1F of
//           0x18: TNDXB1 //0x10 - class static; 0x18 - class procedure
//         endc
//        %$END
        fInline: TInlineF
        //fOverload: TOverloadF
       %$END
      ends
    %$IF (Ver>=7)and IsDelphi;
      arConstr,arDestr: struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA,
          //default property=0x20,virtual=0x40,$80=dynamic
       %$IF (Ver>=8)and IsDelphi;
        FlagsEx: TNDXB1 //For Ver>=8 public=0x1,protected=0x2,published=0x5,class=0x10
       %$END
       %$IF (Ver>=12)and IsDelphi;
        B3: TNDXB1
       %$END
        hDT: TSNDXB1 //VMT index, dynamic index
        Ndx: TNDXB1 //The addr of the method
       %$IF (Ver>=12)and IsDelphi;
        BF: Byte
       %$END
        hImp: TNDXB1
      ends
    %$END
    %$IF (Ver>=13)and IsDelphi;
      arAnonymousBlock: struc pas
        B10: TNDXB1
        B0: TNDXB1
      ends
    %$END
      else struc pas
        Flags: TNDXB1 //public=0x2,protected=0x4,published=0xA,
          //default property=0x20,virtual=0x40,$80=dynamic
          //XE4: 0x40 - [REF]
       %$IF (Ver>=8)and IsDelphi;
        FlagsEx: TNDXB1 //For Ver>=8 public=0x1,protected=0x2,published=0x5,class=0x10
       %$END
       %$IF (Ver>=12)and IsDelphi;
        B3: TNDXB1
        %$IF (Ver>=17)and IsDelphi;
         Decorator: case @.Flags:Val and 0x40 of
          0x40: ulong
         endc
        %$END
       %$END
        hDT: TNDXB1
        Ndx: TNDXB1
      ends
    endc
   ends
  endc
ends:displ=('[',ADDR(&@),']',@)

TProcArgList array of TProcArg ?@.Tag=TProcArgTag.arStop!Char;

//B0: TNDXB1//Byte
//Sz: TNDXB1

%$IF (Ver>=14)and IsDelphi;
TProcData(B1) struc pas
%$ELSE
TProcData struc pas
%$END
 %$IF Ver>2;
  VProc: TNDXB1
 %$END
  hDTRes: TNDXB1
/*!!!Check
 %$IF (Ver>=14)and IsDelphi;
   hClass: case (@.VProc:val=0x4F)and(@:B1 and 0x40<>0) of
     0: TNDXB1
    endc //For methods
   Args: case (@.VProc:val=0x4F)and(@:B1 and 0x40<>0) of
     0: TProcArgList
    endc
 %$ELSE
*/
  %$IF (Ver>=8)and IsDelphi;
   hClass: TNDXB1 //For methods
  %$END
   Args: TProcArgList
// %$END
ends

/*
TProcDataD struc pas
  D: ulong
  Dat: TProcData
ends

TProcInf struc pas
  BProc: Byte
  D: case @.BProc of
    0: struc pas
        B0: Byte
        Vp: TNDXB1
      ends
    1: struc pas
        B0: Byte
        D: case @.B0 of
          3: TProcDataD
        else Word
        endc
      ends
    else TProcDataD
  endc
ends

TEmbeddedProcInf struc pas
//  Tag:TDCU30RecTag
//  Name: Str
  BProc: Byte
  D: case @.BProc of
    0: struc pas
        B0: Byte
        Vp: TNDXB1
      ends
    1: struc pas
        B0: Byte
        W: Word
      ends
    else TProcData
  endc
ends
*/

/*
TProcInf(NoName) struc pas
  BProc: Byte
  D: case @:NoName of
    1: case @@.BProc of
       0: struc pas
         B0: Byte
         Vp: TNDXB1
       ends
       1: struc pas
           B0: Byte
           B1: Byte
           Sz: TNDXB1
         ends
  %$IF Ver>=6;
       3: struc pas
           B0: Byte
           B2: Byte
           B1: Byte
           Sz: TNDXB1
         ends
  %$END
    endc
  else struc pas
     D1: case @@@.BProc of
       0: void
       1: struc pas
           B0: Byte
           D: case @.B0 and 1 of
             1: ulong
           endc
         ends
       else ulong
     endc
     Dat: TProcData
   ends
  endc
ends
*/

TProcInf(NoName) struc pas
  NF: TNameFDecl
  B0: TNDXB1//Byte
  Sz: TNDXB1
 %$IF (Ver>=14)and IsDelphi;
  X: Byte//TNDXB1
 %$END
  D: case @:NoName of
    1: void
  else
  %$IF (Ver>=14)and IsDelphi;
    TProcData(@@.NF.B1:val)
  %$ELSE
    TProcData
  %$END
  endc
ends

%$IF (Ver>=8)and IsDelphi;
TSysProcInf struc pas
//  NF: TNameFDecl
  B80: Byte
  H: TNDXB1
 %$IF (Ver>=12)and IsDelphi;
  B3: TNDXB1
 %$END
  B0: TNDXB1//Byte
  Sz: TNDXB1
 %$IF (Ver>=14)and IsDelphi;
  X: Byte//TNDXB1
  D: TProcData(0)
 %$ELSE
  D: TProcData
 %$END
ends
%$ELSE
TSysProcInf struc pas
  B80: Byte
  H: TNDXB1
ends
%$END

/*
TEmbeddedInf struc pas
  Tag:TDCU30RecTag
  Name: Str
  D: case @.Tag of
    drType: TTypeInf(0)
    drTypeP: TTypePInf
    drVar,drThreadVar: TVarInf
    drVarC: TVarInf
    drProc: TProcInf((@@.Name[0]=0)or(@@.Name='.')) //TEmbeddedProcInf
    drSysProc: TSysProcInf
    drResStr: TVarInf //TResStrDef
  endc
ends

TEmbeddedList array of TEmbeddedInf ?
  /*@.Tag<>TDCU30RecTag.drProc*/
  @.Tag=TDCU30RecTag.drEmbeddedProcEnd!TDCU30RecTag;
*/

TEmbeddedList forward

//// DEFINITIONS

TTypeDefBase struc pas
  RTTISz: TNDXB1 //Size of RTTI for type, if available
  Sz: TNDXB1
  hAddr: TNDXB1 //The # of definition of the type
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X: TNDXB1
  X1: TNDXB1
//  X2: TNDXB1
 %$ELSIF (Ver>=9)and IsDelphi;
  hClass: TNDXB1
 %$END
ends

%$IF (Ver>=8)and IsDelphi;
TTypeDefBase0 struc pas
  RTTISz: TNDXB1 //Size of RTTI for type, if available
/* %$IF (Ver>=12)and IsDelphi;
  RTTISz: Byte //M.b. something else
 %$ELSE
  RTTISz: TNDXB1 //Size of RTTI for type, if available
 %$END*/
  Sz: TNDXB1
  hAddr: TNDXB1
ends
%$ELSE
TTypeDefBase0 TTypeDefBase
%$END

%$IF (Ver>=14)and IsDelphi;
TVoidDefInf struc pas
  Base: TTypeDefBase
 /*
  %$IF (Ver>=15)and IsDelphi;
  X: Byte
  %$ELSE
  X: TNDXB1 //Çäåñü ì.á. òîæå, íî íàäî ïðîâåðèòü
  %$END
  */
  X: Byte//TNDXB1
ends
%$ELSE
TVoidDefInf TTypeDefBase
%$END

TParentInterfaceInf forward

TRecDefInf struc pas
  Base: TTypeDefBase
  B2: Byte
 %$IF MSIL;//(Ver>=8)and IsDelphi;
  %$IF (Ver>=10)and IsDelphi;
   B1: Byte
   //X0: Byte
  %$END
  X: TNDXB1
  I: TParentInterfaceInf
 %$ELSIF (Ver>=9)and IsDelphi;
  %$IF (Ver>=10)and IsDelphi;
   B1: Byte
   X0: Byte
  %$END
  X: TNDXB1
  %$IF (Ver>=12)and IsDelphi;
   X1: TNDXB1
   Z2: TNDXB1
   %$IF (Ver>=13)and IsDelphi;
    Z3: TNDXB1
   %$END
  %$END
 %$END
  Fields: TProcArgList
//  Fields: array[22]of TProcArg
ends

TPtrDefInf struc pas
  Base: TTypeDefBase
  hRefDT: TNDXB1
 %$IF (Ver>=12)and IsDelphi;
  X0: TNDXB1
 %$END
ends

TRangeDefInf struc pas
  Base: TTypeDefBase
  hDTBase: TNDXB1
  Lo: TNDXB1
  Hi: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
// %$ELSIF (Ver=8)and IsDelphi;
  B: TNDXB1
 %$ELSE
  B: Byte
 %$END
ends

TEnumDefInf struc pas
  Base: TTypeDefBase
  hDTBase: TNDXB1
 %$IF (Ver>=12)and IsDelphi;
  X1: TNDXB1
 /* X1: case @.RTTISz:Val=0 of
    0: TNDXB1
   endc*/
 %$END
  Ndx: TNDXB1
  Lo: TNDXB1
  Hi: TNDXB1
 %$IF (Ver>=8)and IsDelphi;
// %$ELSIF (Ver=8)and IsDelphi;
  B: TNDXB1
 %$ELSE
  B: Byte
 %$END
ends

TSetDefInf struc pas
  Base: TTypeDefBase
  BStart: Byte //0-based start byte number
  hDTBase: TNDXB1
ends

%$IF (Ver>=16)and IsDelphi; //From XE3
type bit
TFloatKind0 forward

TFloatKind struc
  TFloatKind0 K
  TBit X
ends

TFloatKind0 enum TBit7 of (
%$ELSE
TFloatKind enum byte of (
%$END
  fkReal48=0, fkSingle=1, fkDouble=2, fkExtended=3, fkComp=4, fkCurrency=5)

type

TFloatDefInf struc pas
  Base: TTypeDefBase
  Kind: TFloatKind
 %$IF (Ver>=16)and IsDelphi;
  X: case @.Kind.X of
   1: Byte
  endc
 %$END
ends

TArrayDefInf struc pas
  Base: TTypeDefBase
  B1: Byte
  hDTNdx: TNDXB1
  hDTEl: TNDXB1
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X: TNDXB1
 %$END
ends

TShortStrDefInf struc pas
  Base: TTypeDefBase
  B1: Byte
  V: TNDXB1
  Ndx1: TNDXB1
 %$IF (Ver>=12)and IsDelphi;
  CodePage: TNDXB1
 %$END
ends

TFileDefInf struc pas
  Base: TTypeDefBase
  hBaseDT: TNDXB1
ends

TStringDefInf struc pas
  Base: TTypeDefBase
  B0: Byte
  B1: TNDXB1//Byte
  hBaseDT: TNDXB1
 %$IF (Ver>=12)and IsDelphi;
  CodePage: TNDXB1
 %$END
ends

TVariantDefInf struc pas
  Base: TTypeDefBase
%$IF Ver>2;
  B: byte
%$END
ends

%$IF Ver=2;

TProcTypeDefInf struc pas
  Base: TTypeDefBase
  hDTRes: TNDXB1
  Bj: TDCU30RecTag
  Args: case @.Bj of
    drEmbeddedProcStart: TProcArgList
  endc
ends

%$ELSE

TProcTypeAddArg TProcArg

TProcTypeDefInf struc pas
  Base: TTypeDefBase
  NDX0: TNDXB1//B0: Byte
  hDTRes: TNDXB1
 /* AddB: case @.B0 and 0x08 of
    0x08: Byte
  endc*/
  AddB: array of TProcTypeAddArg ?(@.Tag=106/*'j'*/)or(@.Tag=99/*'c'*/)!void;
  Bj: TDCU30RecTag
  Args: case @.Bj of
    drEmbeddedProcStart: TProcArgList
  endc
ends

%$END

TObjVMTDefInf struc pas
  Base: TTypeDefBase
  hObjDT: TNDXB1
  VMTSz: TNDXB1
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  X2: TNDXB1
 %$END
ends

TObjDefInf struc pas
  Base: TTypeDefBase
  B03: Byte
  %$IF (Ver>=10)and IsDelphi;
  BX: Byte //TNDXB1 (proof: object in 64-bit) //or m.b. array[@.BxLen]of byte
  %$END
  %$IF (Ver>=14)and IsDelphi;
  BX1: byte
  %$END
  hParent: TNDXB1
  VMTOfs: TNDXB1 //-1=FE => no VMT
  hVMT: TNDXB1 //index in address table
  VMCnt: TNDXB1
  %$IF (Ver>=15)and IsDelphi;
  BX2: TNDXB1
  %$END
  Args: TProcArgList
ends

TParentInterfaceRec struc pas
  hIntf: TNDXB1
 %$IF MSIL and(Ver>=10)and IsDelphi;
   mX1: TNDXB1
   mMCnt: TNDXB1
 %$END
  Cnt: TNDXB1 //Member count
 %$IF Packaged and(Ver>=4);
 // PkgNdx: array[@.Cnt:Val] of TNDXB1
 %$END
 %$IF MSIL; //(Ver>=8)and IsDelphi;
  Member: array[@.Cnt:Val] of struc pas
    N: TNDXB1
    hMember: TNDXB1
   ends
 %$ELSIF (Ver>=10)and IsDelphi;
/*
 %$END
 %$IF (Ver>=10)and IsDelphi;
 */
   X1: TNDXB1
   MCnt: TNDXB1
 %$IF (Ver>=13)and IsDelphi;
    X3: TNDXB1
    X4: TNDXB1
    Match: array[@.MCnt:Val]of struc pas
      B: Byte
      Name: str
      N: TNDXB1
      I: TNDXB1
     ends
  %$END
 %$END
ends

TParentInterfaceInf struc pas
  ICnt: TNDXB1
  ITbl: array[@.ICnt:Val] of TParentInterfaceRec//Byte
ends

TClassDefInf struc pas
  Base: TTypeDefBase
  %$IF (Ver>=10)and IsDelphi;
  BX: byte//TNDXB1
  %$END
  %$IF (Ver>=12)and IsDelphi;
  %$IF (Ver>=15)and IsDelphi;
  BX1: Byte
  %$ELSE
  BX1: TNDXB1 //Çäåñü ì.á. òîæå, íî íàäî ïðîâåðèòü
  %$END
  BX2: byte//TNDXB1
  %$END
  hParent: TNDXB1
  InstBase: TTypeDefBase0
  VMCnt: TNDXB1//B00: Byte
  NdxFE: TNDXB1//BFE: Byte
  PropCnt/*Ndx00a*/: TNDXB1//B00a: Byte
 %$IF (Ver>=8)and IsDelphi;
  B04: TNDXB1
 %$IF (Ver>=13)and IsDelphi;
  BX3: TNDXB1
 %$END
 %$IF not MSIL and Packaged /*and not(IsDelphi and(Ver>=13))*/;
  PkgExtra: case @.B04:Val and 0x8 of
   0x8: struc pas
     V1: TNDXB1 //Usually #1
     Cnt: TNDXB1 //Usually #1
     Tbl: array[@.Cnt:Val]of TNDXB1 //some numbers in descending order //Usually #1
    ends
  endc
 %$END
 %$ELSE
  B04: Byte
 %$IF (Ver>=3)and(Ver<=7)and Packaged;
  PkgExtra: case @.B04 and 0x10 of
   0x10: array[3]of TNDXB1
  endc
 %$END
 %$END
%$IF Ver>2;
/*
  B00b: Byte //always 0 or 2 and was 4 in CorbaObj.dcu
  DAdd: case @.B00b=0 of
      0: struc pas
        B0: Byte
        B1: Byte
       ends
    endc
*/
  I: TParentInterfaceInf
%$END
  Args: TProcArgList
//  Args: array[6]of TProcArg
ends

%$IF (Ver>=8)and IsDelphi;

TMetaClassDefInf struc pas
  Base: TTypeDefBase
  %$IF (Ver>=10)and IsDelphi;
  BX: byte//TNDXB1
  %$END
  %$IF (Ver>=12)and IsDelphi;
  %$IF (Ver>=15)and IsDelphi;
  BX1: Byte
  %$ELSE
  BX1: TNDXB1 //Çäåñü ì.á. òîæå, íî íàäî ïðîâåðèòü
  %$END
  BX2: byte//TNDXB1
  %$END
  hParent: TNDXB1
 %$IF (Ver>=13)and IsDelphi;
  BX3: TNDXB1
 %$END
  InstBase: TTypeDefBase0
  VMCnt: TNDXB1//B00: Byte
  NdxFE: TNDXB1//BFE: Byte
  Ndx00a: TNDXB1//B00a: Byte
 %$IF (Ver>=8)and IsDelphi;
  B04: TNDXB1
 %$ELSE
  B04: Byte
 %$END
/*
  hParent: TNDXB1
  InstBase: TTypeDefBase0
  VMCnt: TNDXB1//B00: Byte
  NdxFE: TNDXB1//BFE: Byte
  Ndx00a: TNDXB1//B00a: Byte
 %$IF (Ver>=8)and IsDelphi;
  B04: TNDXB1
  %$IF (Ver>=10)and IsDelphi;
  BX: TNDXB1
  %$IF (Ver>=12)and IsDelphi;
  BX1: TNDXB1
  BX2: TNDXB1
  %$IF ((Ver<12)or(Ver>=13))and IsDelphi;
   BX3: TNDXB1
  %$END
  %$END
  %$END
 %$ELSE
  B04: Byte
 %$END
*/
%$IF Ver>2;
  //%$IF (Ver<14)or not IsDelphi;
  hCl: TNDXB1  //Only this 2 fields are added in comparison with TClassDefInf
  X: TNDXB1
  //%$END
  I: TParentInterfaceInf
%$END
  Args: TProcArgList
ends

%$END

TGUID struc
  ulong D1
  word D2
  word D3
  array[8] of byte D4
ends

TInterfaceProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag and 0x80 of
    0x80:
   %$IF gen7;
    case @@.Tag of
     TDCU30RecTag.drConstAddInfo: TConstAddInfo
    else void
    endc
   %$ELSE
    void
   %$END
   else struc pas
    Name: Str
    D: case @@@.Tag of
//      arLocType: TTypeInf(1)
      arProperty: TPropInfo
      else struc pas
        Ndx1: TNDXB1
      %$IF (Ver>=8)and IsDelphi;
        B1: TNDXB1
       %$IF (Ver>=12)and IsDelphi;
        X: TNDXB1
       %$END
      %$END
        hDT: TNDXB1
        NDXB: TNDXB1
        Ndx: TNDXB1
      ends
    endc
   ends
  endc
ends

TInterfaceProcArgList array of TInterfaceProcArg ?@.Tag=TProcArgTag.arStop!Char;

TDispInterfaceProcArg struc pas
  Tag: TProcArgTag
  D: case @.Tag and 0x80 of
    0x80:
   %$IF gen7;
    case @@.Tag of
     TDCU30RecTag.drConstAddInfo: TConstAddInfo
    else void
    endc
   %$ELSE
    void
   %$END
   else struc pas
    Name: Str
    D: struc pas
        Ndx1: TNDXB1
      %$IF (Ver>=8)and IsDelphi;
        B1: TNDXB1
      %$END
      %$IF (Ver>=12)and IsDelphi;
        B3: TNDXB1
      %$END
        hDT: TNDXB1
        NDXB: TNDXB1
        Ndx: TNDXB1
      ends
   ends
  endc
ends

TDispInterfaceProcArgList array of TDispInterfaceProcArg ?@.Tag=TProcArgTag.arStop!Char;

TInterfaceDefInf struc pas
  Base: TTypeDefBase
  %$IF (Ver>=12)and IsDelphi;
  BX: byte//TNDXB1
  %$END
  hParent: TNDXB1
  VMCnt: TNDXB1
  GUID: TGUID
  B: Byte //02 for all interfaces, 06 for dispinterface
 %$IF (Ver>=8)and IsDelphi;
  %$IF (Ver>=13)and IsDelphi;
  BY: TNDXB1
  %$END
  Sz: TNDXB1
  D: array[@.Sz:Val] of struc pas
     X: TNDXB1
     Z: TNDXB1
    %$IF MSIL and(Ver>=10)and IsDelphi;
     X1: TNDXB1
     Z1: TNDXB1
    %$END
   ends
 %$END
  Args: case @.B and 0x04 of
    0: TInterfaceProcArgList
  else TDispInterfaceProcArgList
  endc
ends


TCodeBlockInf struc pas
  Sz: TNDXB1
  D: raw[@.Sz:Val]
ends

TFixUpRec struc pas
  dOfs: TNDXB1 //From the start of the previous one
  B1: byte
  N2: TNDXB1
ends

TFixUpData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TFixUpRec
ends

TCodeLinesRec struc pas
  dL: TNDXB1
  dOfs: TNDXB1
ends

TCodeLinesData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TCodeLinesRec
ends

TLineRange struc pas
  Line0: TNDXB1
  LineNum: TNDXB1
  hFile: TNDXB1
ends

TLinNumData struc pas
  Sz: TNDXB1
  Ranges: array[@.Sz:Val] of TLineRange
ends

TStrucScopeRec struc pas //
  hType: TNDXB1
  hVar: TNDXB1 //<>0 for With
  Ofs: TNDXB1 //usually=0
  LnStart: TNDXB1 //1st member line
  LnCnt: TNDXB1 //total member lines
 %$IF (Ver>=25)and IsDelphi;
  X: TNDXB1
 %$END
ends

TStrucScopeData struc pas
  Sz: TNDXB1
  D: array[@.Sz:Val] of TStrucScopeRec
ends

TSymbolRefRec struc pas
  hSym: TNDXB1
  hMember: TNDXB1 //for symbols - type members, else - 0
  Sz: TNDXB1
  hDef: TNDXB1 //index of symbol definition in the L array
  L: array[@.Sz:Val] of TNDXB1
ends

TSymbolRefData struc pas
  Sz: TNDXB1
  NPrimary: TNDXB1 //# of Not member definitions
  D: array[@.Sz:Val] of TSymbolRefRec
ends

%$IF Ver=3;
TUnitFlagsData struc pas
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
ends
%$ELSIF Ver>3;
TUnitFlagsData struc pas
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
%$IF (Ver>9)and(IsDelphi);
  Flags1: TNDXB1
%$END
  Priority: TNDXB1 //Always 0x1E
ends
%$END

%$IF (Ver>=15)and IsDelphi and mode64;
TLocVarFrameCode enum byte of (
  RAX,RCX,RDX,RBX/*!*/,RSP,RBP,RSI/*!*/,RDI, R8,R9,R10,R11,R12,R13,R14,R15, //guess values
   _end_=0x7F
)
%$ELSE
TLocVarFrameCode enum byte of (
  EAX,EDX,ECX,EBX,ESI,EDI,EBP,
 //Register parts:
  AL,DL,CL,BL, AH,DH,CH,BH, AX,DX,CX,BX, _end_=0x7F
)
%$END

TLocVarFrame TNDXB1():displ=(valname((@ as TNDXB1):Val,TLocVarFrameCode),'{',@,'}')

TLocVarInf0 struc pas //DoDi's info
  sym: TNDXB1 //Symbol # in the symbol table, 0 - proc data end
  ofs: TNDXB1 //Offset in procedure code
  frame: TLocVarFrame //-1(0x7f)-symbol end, else - symbol start 0-EAX, 1-EDX,
    //2-ECX, 3-EBX, 4-ESI...
    //Size of local variables for procedures (for SUB ESP,Size)
ends

%$IF (Ver>=15)and IsDelphi and mode64;
TLocVarProcInf struc pas
  sym: TNDXB1 //Symbol # in the symbol table, 0 - proc data end
  ofs: TNDXB1
  LocSz: TNDXB1 //Size of local variables for procedures (for SUB ESP,LocSz-LocSz1)
  V0: TNDXB1
  V1: TNDXB1
  V2: TNDXB1
  V3: TNDXB1
  LocSz1: TNDXB1 //very often
  LocSz1a: TNDXB1//EQ
ends:assert[(@.Ofs:Val and 0x7=0)and(@.LocSz:Val and 0x7=0)
  and(@.V0:Val and 0x7=0)and(@.V0:Val<0x140/*An empirically found by the analysis of LIB64 files value.
    We check this field cause it corresponds to the next sym and it grows quickly for valid syms*/)
  and(@.V1:Val and 0x7=0)/*and(@.V2:Val and 0x7=0)*/
  and(@.V3:Val and 0x7=0)and(@.LocSz1:Val and 0x7=0)and(@.LocSz1a:Val and 0x7=0)]
  //In fact we should check that sym is a procedure
  //but we try to use this heuristics instead

TLocVarInf try
  P: TLocVarProcInf
  V: TLocVarInf0
endt
%$ELSE
TLocVarInf TLocVarInf0
%$END


/*
TLocVarInf struc pas //DoDi's info
  sym: TNDXB1 //Symbol # in the symbol table, 0 - proc data end
  ofs: TNDXB1 //Offset in procedure code
  frame: TLocVarFrame //-1(0x7f)-symbol end, else - symbol start 0-EAX, 1-EDX,
    //2-ECX, 3-EBX, 4-ESI...
    //Size of local variables for procedures (for SUB ESP,Size)
  %$IF (Ver>=15)and IsDelphi and mode64;
  Extra: case ((@.frame as TNDXB1):Val and 0x7=0)and(@.Ofs:Val and 0x7=0) of
//  Extra: case (@.sym:Val=0)or((@.frame as TNDXB1):Val>=0x10)and((@.frame as TNDXB1):Val and 0xF=0) of
//  Extra: case (@.sym:Val=0)or(@.frame:Val and 0xF=0) of
   0: void
   else struc pas
    sym: TNDXB1
    ofs: TNDXB1
    frame: TNDXB1
    sym1: TNDXB1
    ofs1: TNDXB1
    frame1: TNDXB1
   ends
  endc
  %$END
/*
  %$IF (Ver>=15)and IsDelphi;
  frame: Byte
  %$ELSE
  frame: TNDXB1 //-1(0x7f)-symbol end, else - symbol start 0-EAX, 1-EDX,
    //2-ECX, 3-EBX, 4-ESI...
  %$END
  */
ends
*/

TLocVarTbl struc pas
  Sz: TNDXB1
  %$IF (Ver>=15)and IsDelphi and mode64;
  //D: array[@.Sz:Val] of TLocVarInf takes 2 when ((@.frame as TNDXB1):Val and 0x7=0)and(@.Ofs:Val and 0x7=0) exc 1;
  D: array[@.Sz:Val] of TLocVarInf takes 1+(valid @.P);
  %$ELSE
  D: array[@.Sz:Val] of TLocVarInf
  %$END
ends

%$IF (Ver>=7)and IsDelphi;
/*
TUnitAddInfo struc pas
  D: array of char,'c';
ends
%$ELSIF (Ver>=8)and IsDelphi;
*/
TUnitAddInfo struc pas
  NF: TNameFDecl
  B: TNDXB1
  Sub: TDCU30ListC
ends
%$END

%$IF (Ver>=12)and IsDelphi;
TDelayedImpRec struc pas
  N: long
  NDX: TNDXB1
ends

TDynArrayInf struc pas
  Base: TTypeDefBase
  hBaseDT: TNDXB1 //Should be array[0..-1]of ...
  X0: TNDXB1
ends

TTemplateArgInf struc pas
  Base: TTypeDefBase
  Cnt: TNDXB1
  Args: array[@.Cnt:Val]of TNDXB1
  V5: TNDXB1
ends

TTemplateCall struc pas
  Base: TTypeDefBase
 %$IF (Ver>=14)and IsDelphi;
  X: Byte//TNDXB1
 %$END
  hDT: TNDXB1 //The type with `
  Cnt: TNDXB1
  Args: array[@.Cnt:Val]of TNDXB1
  hDTFull: TNDXB1 //The type with actual args in <>
ends
%$END

%$IF (Ver>=8)and IsDelphi;
TORec struc pas
%$IF (Ver>=12)and IsDelphi;
  Name: str
  DW: long
  N: int
  Args: TDCU30ListC //TB0ImpRec
%$ELSE
  B: TNDXB1
%$END
ends


TStrConstRec struc pas
//%$IF (Ver<10);
  NF: TNameFDecl
  V: TNDXB1
  Sz: TNDXB1
 %$IF (Ver>=14)and IsDelphi;
  X: byte//TNDXB1
 %$END
/*
%$ELSE
  NF: TNameFDecl
  hDT: TNDXB1
  L: Byte //drStop1='c' - some list
%$END
*/
ends
%$END


%$IF (Ver>=3)and IsDelphi;
TCPPFlags set 8 of (EXTERNALSYM ^4, NODEFINE ^ 8, NOINCLUDE ^ 0x10, OBJTYPENAME ^ 0x20)

TCPPFlagsRec struc pas
// %$IF (Ver>6);
//  B4: TNDXB1
// %$ELSE
//  B4: Byte
// %$END
  F: TCPPFlags
  hAddr: TNDXB1
ends
%$END

%$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
TAssemblyDataHdr(Sz) struc pas
  F: ulong
  SzPublicKey: ulong
  PublicKey: raw[@.SzPublicKey]
  SzPublicKeyToken: ulong
  PublicKeyToken: raw[@.SzPublicKeyToken]
  Y: ulong
  SzName: ulong
  Name: array[@.SzName]of Char,<0;
  SomeData: raw[0x18]
  //AlName: align 4 at &@.F/*&@.Name*/;
  rest: raw[]
ends:[@:Size=@:Sz]

TAssemblyData struc pas
  HdrSize: TNDXB1
  H: TAssemblyDataHdr(@.HdrSize:Val)
  Descr: str
  Cnt1: TNDXB1
  Tbl1: array[@.Cnt1:Val]of ulong
  Tbl2: array[@.Cnt1:Val]of TNDXB1
  Cnt2: TNDXB1
  Tbl3: array[@.Cnt2:Val]of ulong
  Tbl4: array[@.Cnt2:Val]of ulong
  Tbl5: array[@.Cnt2:Val]of ulong
  Cnt3: TNDXB1
  Tbl6: array[@.Cnt3:Val]of ulong
ends
%$END

//Main Stream Record
TDCU30Rec struc pas
  Tag: TDCU30RecTag
  D: case @.Tag of
      drVoid: TVoidDefInf
      drRecDef: TRecDefInf
      drPtrDef: TPtrDefInf
      drRangeDef,drChRangeDef,drBoolRangeDef,drWCharRangeDef,
      drWideRangeDef: TRangeDefInf
      drEnumDef: TEnumDefInf
      drFloatDef: TFloatDefInf
      drSetDef: TSetDefInf
      drArrayDef: TArrayDefInf
      drShortStrDef: TShortStrDefInf
      drFileDef: TFileDefInf
      drTextDef: TTypeDefBase
      drStringDef,drWideStrDef: TStringDefInf
      drVariantDef: TVariantDefInf
      drProcTypeDef: TProcTypeDefInf
      drObjVMTDef: TObjVMTDefInf
      drObjDef: TObjDefInf
      drClassDef: TClassDefInf
 %$IF (Ver>=8)and IsDelphi;
      drMetaClassDef: TMetaClassDefInf
 %$END
      drInterfaceDef: TInterfaceDefInf
      drEmbeddedProcStart:TEmbeddedList
      drEmbeddedProcEnd: void
      drCBlock: TCodeBlockInf
      drFixUp: TFixUpData
      drCodeLines: TCodeLinesData
      drLinNum: TLinNumData
      drStrucScope: TStrucScopeData
      drSymbolRef: TSymbolRefData
      drLocVarTbl: TLocVarTbl
%$IF Ver>=3;
      drUnitFlags: TUnitFlagsData
%$END
/*
%$IF Ver>=100; //Kylix specific flags
      drUnit3,drUnit3s: array[3]of byte
      drUnit4: ulong
%$END
*/
     %$IF gen7;
       drConstAddInfo: TConstAddInfo
     %$END
     %$IF (Ver>=9)and(Ver<=10)and MSIL;
       drAssemblyInfo: TAssemblyInfo
     %$END
     %$IF (Ver>=7)and IsDelphi;
       drProcAddInfo: TNDXB1//byte //=02
     %$END
     %$IF (Ver>=20)and IsDelphi;
      drNextOverload: TNDXB1
     %$END
     %$IF (Ver>=22)and IsDelphi;
      drDependencyInfo: TDependencyInfoRec
     %$END
     %$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
      drAssemblyData: TAssemblyData
     %$END
      drSetDeft: TSetDeftInfo
     %$IF (Ver>=9)and IsDelphi;
      drStop2: ulong
     %$ELSE
      drStop2: void
     %$END
     %$IF (Ver>=8)and IsDelphi;
      drORec: TORec //goes before drCBlock
     %$END
     %$IF (Ver>=3)and IsDelphi;
      drCPPFlags: TCPPFlagsRec
     %$END
     %$IF (Ver>=10)and IsDelphi;
      drCLine: struc pas
       %$IF (Ver>=14)and IsDelphi;
        X: byte//TNDXB1
       %$END
        Cnt: TNDXB1
        Txt: array[@.Cnt:Val]of Char
       ends
      drA1Info: struc pas
        V0: TNDXB1
        V1: TNDXB1
        V2: TNDXB1
        V3: TNDXB1
        Cnt: TNDXB1
        Tbl: array[@.Cnt:Val]of TNDXB1
       ends
      drA2Info: void
      %$IF (Ver>=12)and IsDelphi;
      arCopyDecl: TNDXB1
      drA5Info: struc pas
      //  bA6: Byte;
      //  X: TNDXB1
       ends
      drA6Info: TDCU30ListC //void
      drA7Info: struc pas
        V1: TNDXB1
        Len: TNDXB1
        Tbl: array[@.Len:Val]of TNDXB1
       ends
      drA8Info: TNDXB1 //The index of template arg address
     %$IF (Ver>=17)and IsDelphi;
      drA9Info: TNDXB1
     %$END
      drDynArrayDef: TDynArrayInf
      drTemplateArgDef: TTemplateArgInf
      drTemplateCall: TTemplateCall
      drUnicodeStringDef: TStringDefInf
       %$IF (Ver>=15)and IsDelphi /*and mode64*/;
        drSegInfo: struc pas
          Len: TNDXB1
          Tbl: array[@.Len:Val] of struc pas
            Name: str
            F: byte
            H: TNDXB1
           ends
         ends
        drAddrToSegInfo: struc pas
          Len: TNDXB1
          Tbl: array[@.Len:Val] of struc pas
            hAddr: TNDXB1 //with data
            hSeg: TNDXB1
            B: Byte
            V2: TNDXB1
            Fix0: TNDXB1 //Starting fixup of the block
            Size: TNDXB1
            V5: TNDXB1
           ends
        ends
       %$END
      %$END
     %$END
     else struc pas
      Name: TNameStr
      D: case @@@.Tag of
        drSrc, drObj, drAsm: TSrcInf
       %$IF Packaged and MSIL/*(Ver=8)*/and IsDelphi;
        drAssemblySrc: TAssemblySrcInf
       %$END
        drRes: TResInf
        drUnit,drUnit1: TUnitInf
       %$IF (Ver>=13)and IsDelphi;
        drUnitInlineSrc: TUnitInlineSrcInf
       %$END
        drDLL: TDllInf
        drType: TTypeInf(0/*NoInf*/)
        drTypeP: TTypePInf
        drImpType,drImpVal: ulong
        drImpTypeDef: TImpTypeDefInf
        drExport: TExportInf
        drVar,drThreadVar: TVarInf
        drVarC: TVarInf
        drAbsVar: TVarInf
       /* drProc: TProcInf((@@.Name[0]=0)or(@@.Name='.')/* for Ver>=6 : */or
          (@@.Name='..'))*/
       %$IF (Ver>=14)and IsDelphi;
        drProc: TProcInf((@@.Name.L=0)or(@@.Name.S[0]='.')or(@@.Name.S[0]='$'))
       %$ELSIF (Ver>=12)and IsDelphi;
        drProc: TProcInf((@@.Name.L=0)or(@@.Name.S[0]='.'))
       %$ELSE
        drProc: TProcInf((@@.Name[0]=0)or(@@.Name[1]='.'))
       %$END
        drSysProc: TSysProcInf
        drConst: TConstDef
        drResStr: TResStrDef
        drLabel: TNDXB1
       %$IF (Ver>=7)and IsDelphi;
        drUnitAddInfo: TUnitAddInfo
       %$END
       %$IF (Ver>=8)and IsDelphi;
        drStrConstRec: TStrConstRec
       %$END
       %$IF (Ver>=10)and IsDelphi;
       /* drStrConstRec
        drAddInfo6: struc pas
           V1: TNDXB1 //0
           Z1: TNDXB1 //0
           V2: TNDXB1 //0
           Z2: TNDXB1 //was<>0
         ends
       */
        drSpecVar: TVarInf
        /*
         struc pas
           V1: TNDXB1 //#23
           Z1: TNDXB1 //0
           V2: TNDXB1 //#17
           Z2: TNDXB1 //0
         ends
        */
       %$END
       %$IF (Ver>=12)and IsDelphi;
        drDelayedImpInfo: TDelayedImpRec
       %$END
      endc
     ends
    endc
ends:displ=('[',ADDR(&@),']',@)

TDCU30List0 array of TDCU30Rec ?((@.Tag<0x61/*'a'*/)and
  (@.Tag<>TDCU30RecTag.drType)and
  (@.Tag<>TDCU30RecTag.drTypeP)and
  (@.Tag<>TDCU30RecTag.drProc)and
  (@.Tag<>TDCU30RecTag.drSysProc)and
  (@.Tag<>TDCU30RecTag.drConst)and
  (@.Tag<>TDCU30RecTag.drResStr)and
  (@.Tag<>TDCU30RecTag.drVar)and
  (@.Tag<>TDCU30RecTag.drThreadVar)and
  (@.Tag<>TDCU30RecTag.drVarC)and
  (@.Tag<>TDCU30RecTag.drAbsVar)and
  (@.Tag<>TDCU30RecTag.drVoid)and
  (@.Tag<>TDCU30RecTag.drLabel)and
  (@.Tag<>TDCU30RecTag.drRecDef)and
  (@.Tag<>TDCU30RecTag.drPtrDef)and
  (@.Tag<>TDCU30RecTag.drRangeDef)and
  (@.Tag<>TDCU30RecTag.drChRangeDef)and
  (@.Tag<>TDCU30RecTag.drWCharRangeDef)and
  (@.Tag<>TDCU30RecTag.drBoolRangeDef)and
  (@.Tag<>TDCU30RecTag.drEnumDef)and
  (@.Tag<>TDCU30RecTag.drFloatDef)and
  (@.Tag<>TDCU30RecTag.drSetDef)and
  (@.Tag<>TDCU30RecTag.drArrayDef)and
  (@.Tag<>TDCU30RecTag.drShortStrDef)and
  (@.Tag<>TDCU30RecTag.drFileDef)and
  (@.Tag<>TDCU30RecTag.drTextDef)and
  (@.Tag<>TDCU30RecTag.drStringDef)and
  (@.Tag<>TDCU30RecTag.drWideStrDef)and
  (@.Tag<>TDCU30RecTag.drWideRangeDef)and
  (@.Tag<>TDCU30RecTag.drVariantDef)and
  (@.Tag<>TDCU30RecTag.drProcTypeDef)and
  (@.Tag<>TDCU30RecTag.drObjVMTDef)and
  (@.Tag<>TDCU30RecTag.drObjDef)and
  (@.Tag<>TDCU30RecTag.drClassDef)and
/*
%$IF Ver>=100; //Kylix specific flags
  (@.Tag<>TDCU30RecTag.drUnit4)and
  (@.Tag<>TDCU30RecTag.drUnit3s)and
%$END
*/
 %$IF (Ver>=7)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drUnitAddInfo)and
 %$END
 %$IF (Ver>=8)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drStrConstRec)and
  (@.Tag<>TDCU30RecTag.drMetaClassDef)and
 %$END
%$IF (Ver>=10)and IsDelphi;
//  (@.Tag<>TDCU30RecTag.drAddInfo6)and
  (@.Tag<>TDCU30RecTag.drSpecVar)and
%$END
 %$IF (Ver>=12)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drDynArrayDef)and
  (@.Tag<>TDCU30RecTag.drTemplateArgDef)and
  (@.Tag<>TDCU30RecTag.drTemplateCall)and
  (@.Tag<>TDCU30RecTag.drUnicodeStringDef)and
 %$END
  (@.Tag<>TDCU30RecTag.drInterfaceDef)
  or(@.Tag=TDCU30RecTag.drStop2)
  or(@.Tag=TDCU30RecTag.drStop_a)
  or(@.Tag>0x7A/*z*/)and
  (@.Tag<>TDCU30RecTag.drCodeLines)and
  (@.Tag<>TDCU30RecTag.drLinNum)and
  (@.Tag<>TDCU30RecTag.drStrucScope)and
  (@.Tag<>TDCU30RecTag.drSymbolRef)and
  (@.Tag<>TDCU30RecTag.drLocVarTbl)and
/*
%$IF Ver>=100; //Kylix specific flags
  (@.Tag<>TDCU30RecTag.drUnit3)and
%$END
*/
// %$IF (Ver>=7)and IsDelphi;
 %$IF gen7;
  (@.Tag<>TDCU30RecTag.drConstAddInfo)and
 %$END
 %$IF (Ver>=9)and(Ver<=10)and MSIL;
  (@.Tag<>TDCU30RecTag.drAssemblyInfo)and
 %$END
 %$IF (Ver>=7)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drProcAddInfo)and
 %$END
 %$IF (Ver>=20)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drNextOverload)and
 %$END
 %$IF (Ver>=22)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drDependencyInfo)and
 %$END
 %$IF (Ver>=8)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drORec)and
 %$END
%$IF (Ver>=3)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drCPPFlags)and
%$END
%$IF (Ver>=10)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drCLine)and
  (@.Tag<>TDCU30RecTag.drA1Info)and
  (@.Tag<>TDCU30RecTag.drA2Info)and
 %$IF (Ver>=12)and IsDelphi;
  (@.Tag<>TDCU30RecTag.arCopyDecl)and
  (@.Tag<>TDCU30RecTag.drA5Info)and
  (@.Tag<>TDCU30RecTag.drA6Info)and
  (@.Tag<>TDCU30RecTag.drA7Info)and
  (@.Tag<>TDCU30RecTag.drA8Info)and
 %$IF (Ver>=17)and IsDelphi;
  (@.Tag<>TDCU30RecTag.drA9Info)and
 %$END
  (@.Tag<>TDCU30RecTag.drDelayedImpInfo)and
 %$END
 %$IF (Ver>=15)and IsDelphi /*and mode64*/;
  (@.Tag<>TDCU30RecTag.drSegInfo)and
  (@.Tag<>TDCU30RecTag.drAddrToSegInfo)and
 %$END
%$END
  (@.Tag<>TDCU30RecTag.drUnitFlags)and
  (@.Tag<>TDCU30RecTag.drSetDeft)
)!TDCU30RecTag;

//TDCU30List0 array of TDCU30Rec ?(@.Tag=0)!Char;
//TDCU30List0 array[100] of TDCU30Rec

TDCU30ListC array of TDCU30Rec ?@.Tag=TDCU30RecTag.drStop1!TDCU30RecTag;
TEmbeddedList array of TDCU30Rec/*TEmbeddedInf*/ ?
  /*@.Tag<>TDCU30RecTag.drProc*/
  @.Tag=TDCU30RecTag.drEmbeddedProcEnd!TDCU30RecTag;

//Unit header record (version-dependent)

%$IF Ver=2;
//Delphi2
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  b00: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=3;
//Delphi3
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=4;
//Delphi4
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
  Bx: Byte
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=5;
//Delphi5
type

TDCUHeader struc pas
  FileSize: ulong
  L1: ulong
  Inf: ulong
//  FT: TFileTime // L1: ulong
//  L2: ulong
  b00: byte
/*
  Tag1: TDCU30RecTag
//  b01: byte
//  Some: raw[@.b01]
  Flags: TNDXB1 //0x500 - WEAKPACKAGEUNIT
  Bx: Byte
*/
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver=6;
//Delphi6
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF (Ver=7)or(Ver=8);
//Delphi7
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  b02: byte
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF (Ver=9)or(Ver=10);
//Delphi2005
//Delphi2006
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  b02: byte
  Name: str
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF (Ver>=12)and(Ver<=25);
//Delphi2009
//Delphi2010
//Delphi XE
//Delphi XE2
//Delphi XE3
//Delphi XE4
//Delphi XE5
//Delphi XE6
//Delphi XE7/AppMethod
//Delphi XE8
//Delphi 10 Seattle
//Delphi 10.1 Berlin
//Delphi 10.2 Tokyo
//Delphi 10.3 Rio
type

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  b02: byte
  Name: str
  bFE: TNDXB1
  X: TNDXB1
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$ELSIF Ver>=100;
//Kylix 1.0,2.0
type

TLXRec struc pas
  F: byte
  D: ulong
ends

/*
TLX0F array of TLXRec?@.F<>0x0F!void;:assert[@[0].F exc 0]
TLX try
  F: TLX0F
  ELS: ulong
endt
*/
TLX0F array of TLXRec?@.F<>0x0F!void;
TELS num+(4):assert[Byte(@)<>TDCU30RecTag.drUnitFlags]
TLX struc
  TLX0F X //This structure was observed in the file QOpenBanner.dcu
    //which displays Kylix nag screen and treated specially by
    //compiler
  try
    ELS: TELS
    NO: void
  endt ELS //Sometimes these 4 bytes are not present, and the 1st byte of
    //of them can have various values such as 0,0x12 or E0.
ends

TDCUHeader struc pas
  FileSize: ulong
  CompileTime: TFileTime //L1: ulong
  Inf: ulong
  b00: byte
  LX: TLX
  Tbl: TDCU30List0
ends//:[@:Size=FileSize]

%$END

data
  0x0004 TDCUHeader Hdr
